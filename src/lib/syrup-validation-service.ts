/**
 * Syrup Validation Service\n * \n * Comprehensive validation system for syrup compatibility testing,\n * dilution accuracy verification, cost calculation validation,\n * and taste profile matching algorithms.\n * \n * @example\n * ```typescript\n * const validator = new SyrupValidationService();\n * const result = await validator.validateSyrupCompatibility(syrup, targetFlavor);\n * const dilutionValid = validator.validateDilutionAccuracy(syrup, ratio, volume);\n * ```\n */\n\nimport { PremadeSyrup, SyrupRecommendation, ComprehensiveCostAnalysis } from '@/lib/types';\nimport { PremadeSyrupService } from '@/lib/premade-syrups';\nimport { DilutionGuideService } from '@/lib/dilution-guides';\nimport { PremadeCostAnalysis } from '@/lib/premade-cost-analysis';\n\n/**\n * Validation Result Interface\n */\ninterface ValidationResult {\n  isValid: boolean;\n  score: number; // 0-100\n  issues: ValidationIssue[];\n  recommendations: string[];\n  confidence: number; // 0-1\n}\n\n/**\n * Validation Issue Interface\n */\ninterface ValidationIssue {\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  category: 'compatibility' | 'dilution' | 'cost' | 'quality' | 'safety';\n  message: string;\n  suggestion?: string;\n  code: string;\n}\n\n/**\n * Compatibility Test Result\n */\ninterface CompatibilityTestResult {\n  flavorMatch: number; // 0-100\n  tasteAlignment: number; // 0-100\n  qualityScore: number; // 0-100\n  dilutionCompatibility: number; // 0-100\n  overallScore: number; // 0-100\n  issues: ValidationIssue[];\n}\n\n/**\n * Dilution Accuracy Test Result\n */\ninterface DilutionAccuracyTestResult {\n  ratioAccuracy: number; // 0-100\n  volumeAccuracy: number; // 0-100\n  concentrationCorrectness: number; // 0-100\n  tastePrediction: number; // 0-100\n  overallAccuracy: number; // 0-100\n  issues: ValidationIssue[];\n}\n\n/**\n * Cost Calculation Test Result\n */\ninterface CostCalculationTestResult {\n  pricingAccuracy: number; // 0-100\n  calculationCorrectness: number; // 0-100\n  regionalAccuracy: number; // 0-100\n  comparisonValidity: number; // 0-100\n  overallAccuracy: number; // 0-100\n  issues: ValidationIssue[];\n}\n\n/**\n * Main Syrup Validation Service\n */\nexport class SyrupValidationService {\n  private syrupService: PremadeSyrupService;\n  private dilutionService: DilutionGuideService;\n  private costAnalysisService: PremadeCostAnalysis;\n\n  constructor() {\n    this.syrupService = new PremadeSyrupService();\n    this.dilutionService = new DilutionGuideService();\n    this.costAnalysisService = new PremadeCostAnalysis(this.syrupService);\n  }\n\n  /**\n   * Validate syrup compatibility with target flavor\n   */\n  async validateSyrupCompatibility(\n    syrup: PremadeSyrup,\n    targetFlavor: string\n  ): Promise<CompatibilityTestResult> {\n    const issues: ValidationIssue[] = [];\n    \n    // Test flavor match\n    const flavorMatch = this.testFlavorMatch(syrup, targetFlavor);\n    if (flavorMatch < 60) {\n      issues.push({\n        severity: 'high',\n        category: 'compatibility',\n        message: `Low flavor compatibility (${flavorMatch}%) for ${targetFlavor}`,\n        suggestion: 'Consider alternative syrups or hybrid approach',\n        code: 'LOW_FLAVOR_MATCH'\n      });\n    }\n    \n    // Test taste alignment\n    const tasteAlignment = this.testTasteAlignment(syrup, targetFlavor);\n    if (tasteAlignment < 50) {\n      issues.push({\n        severity: 'medium',\n        category: 'compatibility',\n        message: `Poor taste profile alignment (${tasteAlignment}%)`,\n        suggestion: 'May require taste adjustments or alternative options',\n        code: 'POOR_TASTE_ALIGNMENT'\n      });\n    }\n    \n    // Test quality score\n    const qualityScore = syrup.rating * 20; // Convert 0-5 rating to 0-100\n    if (qualityScore < 60) {\n      issues.push({\n        severity: 'medium',\n        category: 'quality',\n        message: `Low quality score (${qualityScore.toFixed(0)}%)`,\n        suggestion: 'Consider higher-rated alternatives',\n        code: 'LOW_QUALITY_SCORE'\n      });\n    }\n    \n    // Test dilution compatibility\n    const dilutionCompatibility = this.testDilutionCompatibility(syrup, targetFlavor);\n    if (dilutionCompatibility < 70) {\n      issues.push({\n        severity: 'medium',\n        category: 'dilution',\n        message: `Poor dilution compatibility (${dilutionCompatibility}%)`,\n        suggestion: 'May require custom dilution ratios',\n        code: 'POOR_DILUTION_COMPAT'\n      });\n    }\n    \n    // Calculate overall score\n    const overallScore = Math.round(\n      (flavorMatch + tasteAlignment + qualityScore + dilutionCompatibility) / 4\n    );\n    \n    return {\n      flavorMatch,\n      tasteAlignment,\n      qualityScore,\n      dilutionCompatibility,\n      overallScore,\n      issues\n    };\n  }\n\n  /**\n   * Validate dilution accuracy\n   */\n  validateDilutionAccuracy(\n    syrup: PremadeSyrup,\n    ratio: string,\n    targetVolume: number\n  ): DilutionAccuracyTestResult {\n    const issues: ValidationIssue[] = [];\n    \n    // Test ratio accuracy\n    const ratioAccuracy = this.testRatioAccuracy(syrup, ratio);\n    if (ratioAccuracy < 80) {\n      issues.push({\n        severity: 'high',\n        category: 'dilution',\n        message: `Imprecise dilution ratio (${ratioAccuracy}%)`,\n        suggestion: 'Use manufacturer-recommended ratios for best results',\n        code: 'IMPRE_CISE_RATIO'\n      });\n    }\n    \n    // Test volume accuracy\n    const volumeAccuracy = this.testVolumeAccuracy(targetVolume);\n    if (volumeAccuracy < 85) {\n      issues.push({\n        severity: 'medium',\n        category: 'dilution',\n        message: `Suboptimal volume selection (${volumeAccuracy}%)`,\n        suggestion: 'Consider standard serving sizes for better consistency',\n        code: 'SUBOPTIMAL_VOLUME'\n      });\n    }\n    \n    // Test concentration correctness\n    const concentrationCorrectness = this.testConcentrationCorrectness(syrup, ratio);\n    if (concentrationCorrectness < 75) {\n      issues.push({\n        severity: 'medium',\n        category: 'dilution',\n        message: `Incorrect concentration level (${concentrationCorrectness}%)`,\n        suggestion: 'Adjust ratio based on intended use (coffee, soda, etc.)',\n        code: 'INCORRECT_CONCENTRATION'\n      });\n    }\n    \n    // Test taste prediction\n    const tastePrediction = this.testTastePrediction(syrup, ratio, targetVolume);\n    if (tastePrediction < 70) {\n      issues.push({\n        severity: 'low',\n        category: 'compatibility',\n        message: `Uncertain taste outcome (${tastePrediction}%)`,\n        suggestion: 'Consider taste testing before full preparation',\n        code: 'UNCERTAIN_TASTE'\n      });\n    }\n    \n    const overallAccuracy = Math.round(\n      (ratioAccuracy + volumeAccuracy + concentrationCorrectness + tastePrediction) / 4\n    );\n    \n    return {\n      ratioAccuracy,\n      volumeAccuracy,\n      concentrationCorrectness,\n      tastePrediction,\n      overallAccuracy,\n      issues\n    };\n  }\n\n  /**\n   * Validate cost calculations\n   */\n  async validateCostCalculations(\n    costAnalysis: ComprehensiveCostAnalysis\n  ): Promise<CostCalculationTestResult> {\n    const issues: ValidationIssue[] = [];\n    \n    // Test pricing accuracy\n    const pricingAccuracy = this.testPricingAccuracy(costAnalysis);\n    if (pricingAccuracy < 85) {\n      issues.push({\n        severity: 'high',\n        category: 'cost',\n        message: `Pricing calculations may be inaccurate (${pricingAccuracy}%)`,\n        suggestion: 'Verify regional pricing data and market rates',\n        code: 'PRICING_INACCURACY'\n      });\n    }\n    \n    // Test calculation correctness\n    const calculationCorrectness = this.testCalculationCorrectness(costAnalysis);\n    if (calculationCorrectness < 90) {\n      issues.push({\n        severity: 'critical',\n        category: 'cost',\n        message: `Mathematical errors in cost calculations (${calculationCorrectness}%)`,\n        suggestion: 'Review calculation formulas and verify arithmetic',\n        code: 'CALCULATION_ERRORS'\n      });\n    }\n    \n    // Test regional accuracy\n    const regionalAccuracy = this.testRegionalAccuracy(costAnalysis);\n    if (regionalAccuracy < 80) {\n      issues.push({\n        severity: 'medium',\n        category: 'cost',\n        message: `Regional pricing data may be outdated (${regionalAccuracy}%)`,\n        suggestion: 'Update regional pricing database',\n        code: 'REGIONAL_DATA_OUTDATED'\n      });\n    }\n    \n    // Test comparison validity\n    const comparisonValidity = this.testComparisonValidity(costAnalysis);\n    if (comparisonValidity < 75) {\n      issues.push({\n        severity: 'medium',\n        category: 'cost',\n        message: `Cost comparison methodology concerns (${comparisonValidity}%)`,\n        suggestion: 'Review comparison criteria and weighting factors',\n        code: 'COMPARISON_CONCERNS'\n      });\n    }\n    \n    const overallAccuracy = Math.round(\n      (pricingAccuracy + calculationCorrectness + regionalAccuracy + comparisonValidity) / 4\n    );\n    \n    return {\n      pricingAccuracy,\n      calculationCorrectness,\n      regionalAccuracy,\n      comparisonValidity,\n      overallAccuracy,\n      issues\n    };\n  }\n\n  /**\n   * Validate taste profile matching algorithms\n   */\n  async validateTasteProfileMatching(\n    syrup: PremadeSyrup,\n    targetFlavor: string\n  ): Promise<ValidationResult> {\n    const issues: ValidationIssue[] = [];\n    const recommendations: string[] = [];\n    \n    // Analyze flavor notes alignment\n    const flavorNotesAlignment = this.analyzeFlavorNotesAlignment(syrup, targetFlavor);\n    if (flavorNotesAlignment < 60) {\n      issues.push({\n        severity: 'medium',\n        category: 'compatibility',\n        message: `Limited flavor notes alignment (${flavorNotesAlignment}%)`,\n        suggestion: 'Consider syrups with more diverse flavor notes',\n        code: 'LIMITED_FLAVOR_ALIGNMENT'\n      });\n    }\n    \n    // Analyze sweetness compatibility\n    const sweetnessCompatibility = this.analyzeSweetnessCompatibility(syrup, targetFlavor);\n    if (sweetnessCompatibility < 70) {\n      issues.push({\n        severity: 'low',\n        category: 'compatibility',\n        message: `Sweetness level mismatch (${sweetnessCompatibility}%)`,\n        suggestion: 'May require sweetness adjustment',\n        code: 'SWEETNESS_MISMATCH'\n      });\n    }\n    \n    // Analyze intensity matching\n    const intensityMatching = this.analyzeIntensityMatching(syrup, targetFlavor);\n    if (intensityMatching < 65) {\n      issues.push({\n        severity: 'medium',\n        category: 'compatibility',\n        message: `Intensity level mismatch (${intensityMatching}%)`,\n        suggestion: 'Consider dilution adjustments',\n        code: 'INTENSITY_MISMATCH'\n      });\n    }\n    \n    // Generate recommendations\n    if (flavorNotesAlignment < 70) {\n      recommendations.push('Consider hybrid approach with custom flavor enhancements');\n    }\n    \n    if (sweetnessCompatibility < 70) {\n      recommendations.push('Add natural sweeteners or acids to balance sweetness');\n    }\n    \n    const overallScore = Math.round(\n      (flavorNotesAlignment + sweetnessCompatibility + intensityMatching) / 3\n    );\n    \n    const confidence = this.calculateTasteMatchingConfidence(\n      syrup,\n      targetFlavor,\n      [flavorNotesAlignment, sweetnessCompatibility, intensityMatching]\n    );\n    \n    return {\n      isValid: overallScore >= 60,\n      score: overallScore,\n      issues,\n      recommendations,\n      confidence\n    };\n  }\n\n  /**\n   * Run comprehensive validation suite\n   */\n  async runComprehensiveValidation(\n    syrup: PremadeSyrup,\n    targetFlavor: string,\n    ratio: string,\n    volume: number,\n    costAnalysis?: ComprehensiveCostAnalysis\n  ): Promise<{\n    compatibility: CompatibilityTestResult;\n    dilution: DilutionAccuracyTestResult;\n    cost?: CostCalculationTestResult;\n    tasteProfile: ValidationResult;\n    overallScore: number;\n    summary: string[];\n  }> {\n    const compatibility = await this.validateSyrupCompatibility(syrup, targetFlavor);\n    const dilution = this.validateDilutionAccuracy(syrup, ratio, volume);\n    const tasteProfile = await this.validateTasteProfileMatching(syrup, targetFlavor);\n    \n    let cost: CostCalculationTestResult | undefined;\n    if (costAnalysis) {\n      cost = await this.validateCostCalculations(costAnalysis);\n    }\n    \n    // Calculate overall score\n    const scores = [compatibility.overallScore, dilution.overallAccuracy, tasteProfile.score];\n    if (cost) scores.push(cost.overallAccuracy);\n    \n    const overallScore = Math.round(scores.reduce((sum, score) => sum + score, 0) / scores.length);\n    \n    // Generate summary\n    const summary = this.generateValidationSummary(\n      compatibility,\n      dilution,\n      cost,\n      tasteProfile,\n      overallScore\n    );\n    \n    return {\n      compatibility,\n      dilution,\n      cost,\n      tasteProfile,\n      overallScore,\n      summary\n    };\n  }\n\n  // Private helper methods\n\n  private testFlavorMatch(syrup: PremadeSyrup, targetFlavor: string): number {\n    const targetWords = targetFlavor.toLowerCase().split(/\\s+/);\n    const syrupWords = [\n      syrup.name.toLowerCase(),\n      syrup.category.toLowerCase(),\n      ...syrup.compatibleFlavors.map(f => f.toLowerCase()),\n      ...syrup.tasteProfile.notes.map(n => n.toLowerCase())\n    ];\n    \n    const matches = targetWords.filter(word => \n      syrupWords.some(syrupWord => syrupWord.includes(word))\n    ).length;\n    \n    return Math.min(100, (matches / targetWords.length) * 100);\n  }\n\n  private testTasteAlignment(syrup: PremadeSyrup, targetFlavor: string): number {\n    // Simplified taste alignment test\n    const targetIntensity = this.estimateFlavorIntensity(targetFlavor);\n    const syrupIntensity = this.getIntensityScore(syrup.tasteProfile.intensity);\n    \n    const intensityDiff = Math.abs(targetIntensity - syrupIntensity);\n    return Math.max(0, 100 - (intensityDiff * 20));\n  }\n\n  private testDilutionCompatibility(syrup: PremadeSyrup, targetFlavor: string): number {\n    const recommendedRatios = this.dilutionService.getDilutionRecommendations(syrup, 'beverage');\n    const defaultRatio = syrup.dilutionRatio;\n    \n    // Check if target flavor aligns with dilution recommendations\n    const hasRecommendation = recommendedRatios.some(rec => \n      targetFlavor.toLowerCase().includes(rec.name.toLowerCase()) ||\n      rec.name.toLowerCase().includes(targetFlavor.toLowerCase())\n    );\n    \n    return hasRecommendation ? 85 : 65;\n  }\n\n  private testRatioAccuracy(syrup: PremadeSyrup, ratio: string): number {\n    const recommendedRatio = syrup.dilutionRatio;\n    if (ratio === recommendedRatio) return 100;\n    \n    // Check if ratio is within recommended range\n    const [syrupPart, waterPart] = this.parseRatio(recommendedRatio);\n    const [targetPart, targetWater] = this.parseRatio(ratio);\n    \n    const ratioDiff = Math.abs(\n      (targetPart / targetWater) - (syrupPart / waterPart)\n    );\n    \n    return Math.max(50, 100 - (ratioDiff * 100));\n  }\n\n  private testVolumeAccuracy(volume: number): number {\n    // Check if volume is within reasonable range (100ml - 1000ml)\n    if (volume >= 200 && volume <= 500) return 100;\n    if (volume >= 150 && volume <= 600) return 85;\n    if (volume >= 100 && volume <= 800) return 70;\n    return 50;\n  }\n\n  private testConcentrationCorrectness(syrup: PremadeSyrup, ratio: string): number {\n    // Test if concentration matches syrup type\n    const [part1, part2] = this.parseRatio(ratio);\n    const concentration = part2 / part1;\n    \n    switch (syrup.concentration) {\n      case 'concentrate':\n        return concentration >= 1 && concentration <= 10 ? 90 : 60;\n      case 'ready-to-drink':\n        return concentration >= 2 && concentration <= 5 ? 90 : 60;\n      case 'powder':\n        return concentration >= 5 && concentration <= 20 ? 90 : 60;\n      default:\n        return 70;\n    }\n  }\n\n  private testTastePrediction(syrup: PremadeSyrup, ratio: string, volume: number): number {\n    // Simplified taste prediction based on syrup properties and ratio\n    const baseScore = syrup.rating * 20;\n    const ratioScore = this.testRatioAccuracy(syrup, ratio);\n    const volumeScore = this.testVolumeAccuracy(volume);\n    \n    return Math.round((baseScore + ratioScore + volumeScore) / 3);\n  }\n\n  private testPricingAccuracy(costAnalysis: ComprehensiveCostAnalysis): number {\n    // Check if all cost components are positive and reasonable\n    const { diy, premade, hybrid } = costAnalysis;\n    \n    let score = 100;\n    \n    if (diy.totalCost <= 0 || diy.totalCost > 1000) score -= 20;\n    if (premade.totalCost <= 0 || premade.totalCost > 1000) score -= 20;\n    if (hybrid.totalCost <= 0 || hybrid.totalCost > 1000) score -= 20;\n    \n    // Check for reasonable cost relationships\n    const costRange = Math.max(...[diy.totalCost, premade.totalCost, hybrid.totalCost]) - \n                     Math.min(...[diy.totalCost, premade.totalCost, hybrid.totalCost]);\n    \n    if (costRange > 500) score -= 10; // Large cost differences might indicate errors\n    \n    return Math.max(0, score);\n  }\n\n  private testCalculationCorrectness(costAnalysis: ComprehensiveCostAnalysis): number {\n    let score = 100;\n    \n    // Check per-serving calculations\n    const diyPerServing = costAnalysis.diy.totalCost / 20; // Assuming 20 servings\n    const premadePerServing = costAnalysis.premade.totalCost / 20;\n    const hybridPerServing = costAnalysis.hybrid.totalCost / 20;\n    \n    // Verify that per-serving costs are calculated correctly\n    if (Math.abs(diyPerServing - costAnalysis.diy.costPerServing) > 0.01) score -= 30;\n    if (Math.abs(premadePerServing - costAnalysis.premade.costPerServing) > 0.01) score -= 30;\n    if (Math.abs(hybridPerServing - costAnalysis.hybrid.costPerServing) > 0.01) score -= 30;\n    \n    return Math.max(0, score);\n  }\n\n  private testRegionalAccuracy(costAnalysis: ComprehensiveCostAnalysis): number {\n    // Simplified check for regional data presence\n    const { regionalPricing } = costAnalysis;\n    \n    let score = 0;\n    const checks = [\n      regionalPricing.taxRate > 0,\n      regionalPricing.shippingCost >= 0,\n      regionalPricing.availabilityFactor >= 0 && regionalPricing.availabilityFactor <= 1\n    ];\n    \n    score = (checks.filter(Boolean).length / checks.length) * 100;\n    \n    return score;\n  }\n\n  private testComparisonValidity(costAnalysis: ComprehensiveCostAnalysis): number {\n    // Check if comparison makes logical sense\n    let score = 80;\n    \n    // Check recommendation confidence\n    if (costAnalysis.recommendation.confidence < 60) score -= 10;\n    if (costAnalysis.recommendation.confidence < 40) score -= 10;\n    \n    // Check if reasoning is provided\n    if (costAnalysis.recommendation.reasoning.length === 0) score -= 15;\n    \n    return Math.max(0, score);\n  }\n\n  private analyzeFlavorNotesAlignment(syrup: PremadeSyrup, targetFlavor: string): number {\n    const targetWords = targetFlavor.toLowerCase().split(/\\s+/);\n    const flavorNotes = syrup.tasteProfile.notes.map(note => note.toLowerCase());\n    \n    const matches = targetWords.filter(word => \n      flavorNotes.some(note => note.includes(word) || word.includes(note))\n    ).length;\n    \n    return Math.min(100, (matches / targetWords.length) * 100);\n  }\n\n  private analyzeSweetnessCompatibility(syrup: PremadeSyrup, targetFlavor: string): number {\n    const targetSweetness = this.estimateSweetnessLevel(targetFlavor);\n    const syrupSweetness = this.getSweetnessScore(syrup.tasteProfile.sweetness);\n    \n    const diff = Math.abs(targetSweetness - syrupSweetness);\n    return Math.max(0, 100 - (diff * 25));\n  }\n\n  private analyzeIntensityMatching(syrup: PremadeSyrup, targetFlavor: string): number {\n    const targetIntensity = this.estimateFlavorIntensity(targetFlavor);\n    const syrupIntensity = this.getIntensityScore(syrup.tasteProfile.intensity);\n    \n    const diff = Math.abs(targetIntensity - syrupIntensity);\n    return Math.max(0, 100 - (diff * 20));\n  }\n\n  private calculateTasteMatchingConfidence(\n    syrup: PremadeSyrup,\n    targetFlavor: string,\n    scores: number[]\n  ): number {\n    const averageScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;\n    \n    // Adjust confidence based on syrup quality and rating\n    const qualityMultiplier = syrup.rating / 5;\n    \n    return Math.min(1, (averageScore / 100) * qualityMultiplier);\n  }\n\n  private generateValidationSummary(\n    compatibility: CompatibilityTestResult,\n    dilution: DilutionAccuracyTestResult,\n    cost: CostCalculationTestResult | undefined,\n    tasteProfile: ValidationResult,\n    overallScore: number\n  ): string[] {\n    const summary: string[] = [];\n    \n    if (overallScore >= 85) {\n      summary.push('Excellent compatibility and accuracy');\n    } else if (overallScore >= 70) {\n      summary.push('Good compatibility with minor issues');\n    } else if (overallScore >= 55) {\n      summary.push('Acceptable compatibility with some concerns');\n    } else {\n      summary.push('Significant compatibility issues detected');\n    }\n    \n    if (compatibility.overallScore < 60) {\n      summary.push('Consider alternative syrups for better flavor match');\n    }\n    \n    if (dilution.overallAccuracy < 70) {\n      summary.push('Review dilution ratios for optimal results');\n    }\n    \n    if (tasteProfile.score < 65) {\n      summary.push('May require taste adjustments or hybrid approach');\n    }\n    \n    if (cost && cost.overallAccuracy < 80) {\n      summary.push('Cost calculations need verification');\n    }\n    \n    return summary;\n  }\n\n  // Helper methods for estimation\n\n  private estimateFlavorIntensity(flavor: string): number {\n    const intenseFlavors = ['cola', 'coffee', 'chocolate', 'caramel', 'peppermint'];\n    const mildFlavors = ['vanilla', 'cream', 'fruit', 'citrus', 'berry'];\n    \n    if (intenseFlavors.some(f => flavor.toLowerCase().includes(f))) return 4;\n    if (mildFlavors.some(f => flavor.toLowerCase().includes(f))) return 2;\n    return 3;\n  }\n\n  private estimateSweetnessLevel(flavor: string): number {\n    const sweetFlavors = ['vanilla', 'caramel', 'hazelnut', 'strawberry', 'raspberry'];\n    const tartFlavors = ['lemon', 'lime', 'cranberry', 'grapefruit'];\n    \n    if (sweetFlavors.some(f => flavor.toLowerCase().includes(f))) return 4;\n    if (tartFlavors.some(f => flavor.toLowerCase().includes(f))) return 2;\n    return 3;\n  }\n\n  private getSweetnessScore(sweetness: string): number {\n    switch (sweetness) {\n      case 'very-low': return 1;\n      case 'low': return 2;\n      case 'medium': return 3;\n      case 'high': return 4;\n      case 'very-high': return 5;\n      default: return 3;\n    }\n  }\n\n  private getIntensityScore(intensity: string): number {\n    switch (intensity) {\n      case 'very-mild': return 1;\n      case 'mild': return 2;\n      case 'moderate': return 3;\n      case 'strong': return 4;\n      case 'very-strong': return 5;\n      default: return 3;\n    }\n  }\n\n  private parseRatio(ratio: string): [number, number] {\n    const match = ratio.match(/(\\d+)\\s*:\\s*(\\d+)/);\n    if (!match) return [1, 1];\n    return [parseInt(match[1]), parseInt(match[2])];\n  }\n}\n\nexport default SyrupValidationService;"
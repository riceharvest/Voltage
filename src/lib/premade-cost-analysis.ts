/**
 * Premade Cost Analysis Engine
 * 
 * Provides comprehensive cost analysis comparing DIY ingredient-based recipes
 * versus commercial syrup approaches. Includes detailed breakdowns, regional
 * pricing analysis, bulk purchasing recommendations, and quality/value assessments.
 * 
 * @example
 * ```typescript\n * import { PremadeCostAnalysis } from './premade-cost-analysis';\n * \n * const costAnalyzer = new PremadeCostAnalysis();\n * const analysis = await costAnalyzer.analyzeCostComparison('vanilla', {\n *   diyRecipe: diyRecipe,\n *   targetServingSize: 250,\n *   batchSize: 20,\n *   region: 'EU'\n * });\n * console.log(analysis.recommendation);\n * ```\n */\n\nimport { PremadeSyrup, CostComparison } from './types';\nimport { PremadeSyrupService } from './premade-syrups';\n\n/**\n * Detailed Cost Analysis Input\n * \n * Configuration for cost analysis including recipe details,\n * regional preferences, and optimization criteria.\n */\nexport interface CostAnalysisInput {\n  targetFlavor: string;\n  diyRecipe: {\n    ingredients: Array<{\n      id: string;\n      name: string;\n      amount: number;\n      unit: string;\n      cost: number;\n      supplier: string;\n      shelfLife: number; // days\n    }>;\n    laborTime: number; // minutes\n    equipmentNeeded: string[];\n    difficulty: 'beginner' | 'intermediate' | 'advanced';\n  };\n  targetServingSize: number; // ml\n  batchSize: number; // servings\n  region?: string;\n  currency?: string;\n  qualityPreference?: 'budget' | 'standard' | 'premium';\n  timeframe?: 'immediate' | 'weekly' | 'monthly';\n}\n\n/**\n * Regional Pricing Data\n * \n * Comprehensive pricing information across different regions\n * with exchange rates and availability factors.\n */\nexport interface RegionalPricingData {\n  region: string;\n  currency: string;\n  exchangeRate: number;\n  taxRate: number;\n  shippingCost: number;\n  importFees: number;\n  availabilityFactor: number; // 0-1, availability confidence\n  priceHistory: {\n    date: string;\n    price: number;\n    currency: string;\n  }[];\n}\n\n/**\n * Bulk Purchasing Recommendation\n * \n * Optimal purchasing strategy for cost savings including\n * break-even points and volume discounts.\n */\nexport interface BulkPurchasingRecommendation {\n  productId: string;\n  recommendedQuantity: number;\n  unitSize: string;\n  unitPrice: number;\n  totalPrice: number;\n  savings: number;\n  savingsPercentage: number;\n  breakEvenPoint: number; // servings\n  shelfLifeConsideration: {\n    productShelfLife: number; // days\n    usageRate: number; // servings per day\n    wasteRisk: 'low' | 'medium' | 'high';\n    recommendation: string;\n  };\n  storageRequirements: {\n    spaceNeeded: string;\n    temperature: string;\n    humidity: string;\n  };\n}\n\n/**\n * Quality Value Assessment\n * \n * Comprehensive evaluation of cost versus quality factors\n * including taste, convenience, and value propositions.\n */\nexport interface QualityValueAssessment {\n  tasteScore: number; // 0-100\n  convenienceScore: number; // 0-100\n  qualityScore: number; // 0-100\n  freshnessScore: number; // 0-100\n  consistencyScore: number; // 0-100\n  valueScore: number; // 0-100\n  overallRating: number; // 0-100\n  strengths: string[];\n  weaknesses: string[];\n  valueProposition: string;\n  recommendation: 'highly-recommended' | 'recommended' | 'conditional' | 'not-recommended';\n}\n\n/**\n * Comprehensive Cost Analysis Result\n * \n * Complete cost analysis with detailed breakdowns, comparisons,\n * and actionable recommendations.\n */\nexport interface ComprehensiveCostAnalysis {\n  targetFlavor: string;\n  region: string;\n  currency: string;\n  analysisDate: string;\n  \n  // Cost Comparisons\n  diy: {\n    ingredientCost: number;\n    laborCost: number;\n    equipmentCost: number;\n    totalCost: number;\n    costPerServing: number;\n    costBreakdown: {\n      ingredients: Record<string, number>;\n      labor: Record<string, number>;\n      equipment: Record<string, number>;\n    };\n    hiddenCosts: {\n      wasteFactor: number; // percentage\n      qualityVariation: number; // 0-100\n      timeInvestment: number; // minutes\n      skillRequired: number; // 1-5 scale\n    };\n  };\n  \n  premade: {\n    syrupCost: number;\n    additionalIngredients: number;\n    laborCost: number;\n    totalCost: number;\n    costPerServing: number;\n    costBreakdown: {\n      syrup: Record<string, number>;\n      additions: Record<string, number>;\n      labor: Record<string, number>;\n    };\n    shelfLifeValue: number; // cost per day of shelf life\n    convenienceValue: number; // time saved value\n  };\n  \n  hybrid: {\n    baseSyrupCost: number;\n    customAdditionsCost: number;\n    laborCost: number;\n    totalCost: number;\n    costPerServing: number;\n    optimizationPotential: number; // percentage improvement possible\n  };\n  \n  // Quality Assessments\n  qualityAssessment: {\n    diy: QualityValueAssessment;\n    premade: QualityValueAssessment;\n    hybrid: QualityValueAssessment;\n  };\n  \n  // Regional Analysis\n  regionalPricing: RegionalPricingData;\n  \n  // Bulk Recommendations\n  bulkRecommendations: BulkPurchasingRecommendation[];\n  \n  // Recommendations\n  recommendation: {\n    preferred: 'diy' | 'premade' | 'hybrid';\n    confidence: number; // 0-100\n    reasoning: string[];\n    alternativeScenarios: Array<{\n      scenario: string;\n      approach: 'diy' | 'premade' | 'hybrid';\n      cost: number;\n      quality: number;\n      whenToUse: string;\n    }>;\n  };\n  \n  // Optimization Opportunities\n  optimizationOpportunities: {\n    costReduction: Array<{\n      type: 'bulk-purchase' | 'substitution' | 'process-optimization';\n      potentialSavings: number;\n      implementation: string;\n      difficulty: 'easy' | 'moderate' | 'complex';\n    }>;\n    qualityImprovement: Array<{\n      type: 'ingredient-upgrade' | 'technique-improvement' | 'equipment-enhancement';\n      costImpact: number;\n      qualityGain: number;\n      recommendation: string;\n    }>;\n  };\n  \n  // Market Analysis\n  marketTrends: {\n    priceVolatility: 'low' | 'medium' | 'high';\n    seasonalFactors: {\n      factor: string;\n      impact: number; // percentage\n      timing: string;\n    }[];\n    futureOutlook: {\n      priceDirection: 'increasing' | 'stable' | 'decreasing';\n      confidence: number;\n      timeframe: string;\n    };\n  };\n}\n\n/**\n * Premade Cost Analysis Engine\n * \n * Advanced cost analysis system for comparing DIY vs commercial approaches\n * with regional pricing, bulk purchasing optimization, and quality assessments.\n */\nexport class PremadeCostAnalysis {\n  private syrupService: PremadeSyrupService;\n  private regionalPricing: Map<string, RegionalPricingData> = new Map();\n  private ingredientCosts: Map<string, number> = new Map();\n  private equipmentCosts: Map<string, number> = new Map();\n  \n  constructor(syrupService: PremadeSyrupService) {\n    this.syrupService = syrupService;\n    this.initializeRegionalPricing();\n    this.initializeIngredientCosts();\n    this.initializeEquipmentCosts();\n  }\n\n  /**\n   * Initialize regional pricing data\n   */\n  private initializeRegionalPricing(): void {\n    this.regionalPricing.set('US', {\n      region: 'US',\n      currency: 'USD',\n      exchangeRate: 1.0,\n      taxRate: 0.08,\n      shippingCost: 5.99,\n      importFees: 0,\n      availabilityFactor: 0.95,\n      priceHistory: [\n        { date: '2024-01-01', price: 12.99, currency: 'USD' },\n        { date: '2024-06-01', price: 13.49, currency: 'USD' },\n        { date: '2024-12-01', price: 12.99, currency: 'USD' }\n      ]\n    });\n    \n    this.regionalPricing.set('EU', {\n      region: 'EU',\n      currency: 'EUR',\n      exchangeRate: 0.85,\n      taxRate: 0.21,\n      shippingCost: 4.99,\n      importFees: 0,\n      availabilityFactor: 0.90,\n      priceHistory: [\n        { date: '2024-01-01', price: 11.99, currency: 'EUR' },\n        { date: '2024-06-01', price: 12.49, currency: 'EUR' },\n        { date: '2024-12-01', price: 11.99, currency: 'EUR' }\n      ]\n    });\n    \n    this.regionalPricing.set('UK', {\n      region: 'UK',\n      currency: 'GBP',\n      exchangeRate: 0.75,\n      taxRate: 0.20,\n      shippingCost: 3.99,\n      importFees: 0,\n      availabilityFactor: 0.85,\n      priceHistory: [\n        { date: '2024-01-01', price: 10.99, currency: 'GBP' },\n        { date: '2024-06-01', price: 11.49, currency: 'GBP' },\n        { date: '2024-12-01', price: 10.99, currency: 'GBP' }\n      ]\n    });\n    \n    this.regionalPricing.set('NL', {\n      region: 'NL',\n      currency: 'EUR',\n      exchangeRate: 0.85,\n      taxRate: 0.21,\n      shippingCost: 3.99,\n      importFees: 0,\n      availabilityFactor: 0.95,\n      priceHistory: [\n        { date: '2024-01-01', price: 11.49, currency: 'EUR' },\n        { date: '2024-06-01', price: 11.99, currency: 'EUR' },\n        { date: '2024-12-01', price: 11.49, currency: 'EUR' }\n      ]\n    });\n  }\n\n  /**\n   * Initialize ingredient cost database\n   */\n  private initializeIngredientCosts(): void {\n    const costs = {\n      // Extracts\n      'madagascar-vanilla-extract': 25.00,\n      'coffee-extract': 20.00,\n      'caramel-extract': 18.00,\n      'hazelnut-extract': 22.00,\n      'peppermint-extract': 16.00,\n      'orange-extract': 15.00,\n      \n      // Essential Oils\n      'orange-essential-oil': 30.00,\n      'peppermint-oil': 28.00,\n      'lemon-essential-oil': 32.00,\n      'lime-essential-oil': 32.00,\n      \n      // Acids and Preservatives\n      'citric-acid': 8.00,\n      'malic-acid': 12.00,\n      'tartaric-acid': 15.00,\n      'potassium-sorbate': 10.00,\n      \n      // Sweeteners\n      'simple-syrup': 5.00,\n      'honey-syrup': 12.00,\n      'brown-sugar-syrup': 8.00,\n      'agave-syrup': 15.00,\n      'maple-syrup': 18.00,\n      \n      // Bases\n      'distilled-water': 1.00,\n      'spring-water': 2.00,\n      'carbonated-water': 3.00,\n      \n      // Flavor Concentrates\n      'fruit-puree-concentrate': 25.00,\n      'berry-concentrate': 22.00,\n      'citrus-concentrate': 20.00,\n      \n      // Powders\n      'cinnamon-powder': 12.00,\n      'nutmeg-powder': 15.00,\n      'ginger-powder': 14.00,\n      'cardamom-powder': 20.00\n    };\n    \n    Object.entries(costs).forEach(([id, cost]) => {\n      this.ingredientCosts.set(id, cost);\n    });\n  }\n\n  /**\n   * Initialize equipment cost database\n   */\n  private initializeEquipmentCosts(): void {\n    const costs = {\n      'digital-scale': 25.00,\n      'measuring-cups': 15.00,\n      'mixing-bowls': 20.00,\n      'whisk': 8.00,\n      'spatula': 6.00,\n      'storage-containers': 12.00,\n      'labels': 5.00,\n      'pH-meter': 45.00,\n      'refractometer': 80.00,\n      'carbonation-system': 150.00,\n      'vacuum-sealer': 60.00\n    };\n    \n    Object.entries(costs).forEach(([id, cost]) => {\n      this.equipmentCosts.set(id, cost);\n    });\n  }\n\n  /**\n   * Perform comprehensive cost analysis\n   */\n  public async analyzeCostComparison(input: CostAnalysisInput): Promise<ComprehensiveCostAnalysis> {\n    const {\n      targetFlavor,\n      diyRecipe,\n      targetServingSize,\n      batchSize,\n      region = 'EU',\n      currency = 'EUR',\n      qualityPreference = 'standard',\n      timeframe = 'monthly'\n    } = input;\n\n    // Get regional pricing data\n    const regionalData = this.regionalPricing.get(region) || this.regionalPricing.get('EU')!;\n    \n    // Analyze DIY costs\n    const diyAnalysis = this.analyzeDiyCosts(diyRecipe, batchSize, regionalData);\n    \n    // Get premade syrup recommendations\n    const syrupRecommendations = this.syrupService.getRecommendations(targetFlavor, {\n      availability: 'in-stock'\n    });\n    \n    if (syrupRecommendations.length === 0) {\n      throw new Error(`No syrups found for flavor: ${targetFlavor}`);\n    }\n    \n    // Analyze premade costs\n    const premadeAnalysis = this.analyzePremadeCosts(\n      syrupRecommendations[0].syrup,\n      batchSize,\n      regionalData,\n      qualityPreference\n    );\n    \n    // Analyze hybrid costs\n    const hybridAnalysis = this.analyzeHybridCosts(\n      syrupRecommendations[0].syrup,\n      diyRecipe,\n      batchSize,\n      regionalData\n    );\n    \n    // Calculate quality assessments\n    const qualityAssessment = this.calculateQualityAssessments(\n      diyAnalysis,\n      premadeAnalysis,\n      hybridAnalysis,\n      qualityPreference\n    );\n    \n    // Generate bulk purchasing recommendations\n    const bulkRecommendations = this.generateBulkRecommendations(\n      syrupRecommendations[0].syrup,\n      batchSize,\n      regionalData,\n      timeframe\n    );\n    \n    // Determine overall recommendation\n    const recommendation = this.determineRecommendation(\n      diyAnalysis,\n      premadeAnalysis,\n      hybridAnalysis,\n      qualityAssessment,\n      qualityPreference\n    );\n    \n    // Generate optimization opportunities\n    const optimizationOpportunities = this.generateOptimizationOpportunities(\n      diyAnalysis,\n      premadeAnalysis,\n      hybridAnalysis,\n      targetFlavor\n    );\n    \n    // Analyze market trends\n    const marketTrends = this.analyzeMarketTrends(syrupRecommendations[0].syrup);\n    \n    return {\n      targetFlavor,\n      region,\n      currency,\n      analysisDate: new Date().toISOString(),\n      diy: diyAnalysis,\n      premade: premadeAnalysis,\n      hybrid: hybridAnalysis,\n      qualityAssessment,\n      regionalPricing: regionalData,\n      bulkRecommendations,\n      recommendation,\n      optimizationOpportunities,\n      marketTrends\n    };\n  }\n\n  /**\n   * Analyze DIY recipe costs\n   */\n  private analyzeDiyCosts(\n    diyRecipe: CostAnalysisInput['diyRecipe'],\n    batchSize: number,\n    regionalData: RegionalPricingData\n  ): ComprehensiveCostAnalysis['diy'] {\n    // Calculate ingredient costs\n    const ingredientCost = diyRecipe.ingredients.reduce((total, ingredient) => {\n      return total + ingredient.cost;\n    }, 0);\n    \n    // Calculate labor cost (hourly rate varies by region)\n    const hourlyRate = this.getRegionalHourlyRate(regionalData.region);\n    const laborCost = (diyRecipe.laborTime / 60) * hourlyRate;\n    \n    // Calculate equipment amortization\n    const equipmentCost = diyRecipe.equipmentNeeded.reduce((total, equipment) => {\n      const cost = this.equipmentCosts.get(equipment) || 0;\n      // Amortize over 100 uses\n      return total + (cost / 100);\n    }, 0);\n    \n    const totalCost = ingredientCost + laborCost + equipmentCost;\n    const costPerServing = totalCost / batchSize;\n    \n    // Calculate hidden costs\n    const wasteFactor = this.calculateWasteFactor(diyRecipe);\n    const qualityVariation = this.calculateQualityVariation(diyRecipe.difficulty);\n    \n    return {\n      ingredientCost,\n      laborCost,\n      equipmentCost,\n      totalCost,\n      costPerServing,\n      costBreakdown: {\n        ingredients: diyRecipe.ingredients.reduce((acc, ing) => {\n          acc[ing.name] = ing.cost;\n          return acc;\n        }, {} as Record<string, number>),\n        labor: { preparation: laborCost },\n        equipment: diyRecipe.equipmentNeeded.reduce((acc, equipment) => {\n          const cost = this.equipmentCosts.get(equipment) || 0;\n          acc[equipment] = cost / 100; // Amortized cost\n          return acc;\n        }, {} as Record<string, number>)\n      },\n      hiddenCosts: {\n        wasteFactor,\n        qualityVariation,\n        timeInvestment: diyRecipe.laborTime,\n        skillRequired: this.getSkillRating(diyRecipe.difficulty)\n      }\n    };\n  }\n\n  /**\n   * Analyze premade syrup costs\n   */\n  private analyzePremadeCosts(\n    syrup: PremadeSyrup,\n    batchSize: number,\n    regionalData: RegionalPricingData,\n    qualityPreference: CostAnalysisInput['qualityPreference']\n  ): ComprehensiveCostAnalysis['premade'] {\n    // Get syrup price in regional currency\n    const regionalPricing = syrup.regionalPricing[regionalData.region] || \n                           Object.values(syrup.regionalPricing)[0];\n    \n    let basePrice = regionalPricing.price;\n    \n    // Apply quality preference adjustments\n    if (qualityPreference === 'premium' && syrup.rating < 4.5) {\n      basePrice *= 1.2; // Premium users pay more for better quality\n    }\n    \n    // Calculate total syrup needed for batch\n    const syrupNeeded = this.calculateSyrupNeeded(batchSize, syrup.dilutionRatio);\n    const syrupCost = (basePrice / 750) * syrupNeeded; // Assuming 750ml bottles\n    \n    // Additional ingredients (minimal for premade)\n    const additionalIngredients = syrupNeeded * 0.1; // 10% of syrup cost for water/ice\n    \n    // Labor cost (much lower for premade)\n    const laborCost = (5 / 60) * this.getRegionalHourlyRate(regionalData.region);\n    \n    const totalCost = syrupCost + additionalIngredients + laborCost;\n    const costPerServing = totalCost / batchSize;\n    \n    // Calculate value metrics\n    const shelfLifeValue = this.calculateShelfLifeValue(syrup);\n    const convenienceValue = this.calculateConvenienceValue(diyLaborTime: 0, premadeLaborTime: 5);\n    \n    return {\n      syrupCost,\n      additionalIngredients,\n      laborCost,\n      totalCost,\n      costPerServing,\n      costBreakdown: {\n        syrup: { [syrup.name]: syrupCost },\n        additions: { water: additionalIngredients * 0.7, ice: additionalIngredients * 0.3 },\n        labor: { preparation: laborCost }\n      },\n      shelfLifeValue,\n      convenienceValue\n    };\n  }\n\n  /**\n   * Analyze hybrid approach costs\n   */\n  private analyzeHybridCosts(\n    syrup: PremadeSyrup,\n    diyRecipe: CostAnalysisInput['diyRecipe'],\n    batchSize: number,\n    regionalData: RegionalPricingData\n  ): ComprehensiveCostAnalysis['hybrid'] {\n    // Base syrup cost\n    const regionalPricing = syrup.regionalPricing[regionalData.region] || \n                           Object.values(syrup.regionalPricing)[0];\n    const syrupNeeded = this.calculateSyrupNeeded(batchSize, syrup.dilutionRatio);\n    const baseSyrupCost = (regionalPricing.price / 750) * syrupNeeded;\n    \n    // Custom additions (select few high-impact ingredients)\n    const customAdditionsCost = this.calculateCustomAdditionsCost(diyRecipe, 0.3); // 30% of DIY ingredients\n    \n    // Labor cost (moderate for hybrid)\n    const laborCost = (12 / 60) * this.getRegionalHourlyRate(regionalData.region);\n    \n    const totalCost = baseSyrupCost + customAdditionsCost + laborCost;\n    const costPerServing = totalCost / batchSize;\n    \n    // Calculate optimization potential\n    const optimizationPotential = this.calculateOptimizationPotential(\n      baseSyrupCost,\n      customAdditionsCost,\n      diyRecipe\n    );\n    \n    return {\n      baseSyrupCost,\n      customAdditionsCost,\n      laborCost,\n      totalCost,\n      costPerServing,\n      optimizationPotential\n    };\n  }\n\n  /**\n   * Calculate quality value assessments\n   */\n  private calculateQualityAssessments(\n    diy: ComprehensiveCostAnalysis['diy'],\n    premade: ComprehensiveCostAnalysis['premade'],\n    hybrid: ComprehensiveCostAnalysis['hybrid'],\n    qualityPreference: CostAnalysisInput['qualityPreference']\n  ): ComprehensiveCostAnalysis['qualityAssessment'] {\n    const diyAssessment = this.assessDiyQuality(diy, qualityPreference);\n    const premadeAssessment = this.assessPremadeQuality(premade, qualityPreference);\n    const hybridAssessment = this.assessHybridQuality(hybrid, qualityPreference);\n    \n    return {\n      diy: diyAssessment,\n      premade: premadeAssessment,\n      hybrid: hybridAssessment\n    };\n  }\n\n  /**\n   * Assess DIY quality\n   */\n  private assessDiyQuality(\n    diy: ComprehensiveCostAnalysis['diy'],\n    qualityPreference: CostAnalysisInput['qualityPreference']\n  ): QualityValueAssessment {\n    const tasteScore = Math.min(100, 95 - diy.hiddenCosts.qualityVariation);\n    const convenienceScore = Math.max(20, 100 - (diy.hiddenCosts.timeInvestment * 2));\n    const qualityScore = Math.min(100, 90 - diy.hiddenCosts.wasteFactor);\n    const freshnessScore = 95; // DIY is freshest\n    const consistencyScore = Math.max(30, 100 - diy.hiddenCosts.qualityVariation);\n    const valueScore = this.calculateValueScore(diy.costPerServing, tasteScore, convenienceScore);\n    const overallRating = (tasteScore + convenienceScore + qualityScore + freshnessScore + consistencyScore) / 5;\n    \n    const strengths = [\n      'Maximum freshness and flavor control',\n      'No artificial preservatives or additives',\n      'Complete ingredient transparency',\n      'Customizable to personal taste'\n    ];\n    \n    const weaknesses = [\n      'Time-intensive preparation',\n      'Requires culinary skills',\n      'Potential for inconsistency',\n      'Higher initial equipment investment'\n    ];\n    \n    return {\n      tasteScore,\n      convenienceScore,\n      qualityScore,\n      freshnessScore,\n      consistencyScore,\n      valueScore,\n      overallRating,\n      strengths,\n      weaknesses,\n      valueProposition: 'Best for enthusiasts who prioritize fresh, natural ingredients and don\\'t mind investing time in preparation',\n      recommendation: overallRating > 75 ? 'recommended' : 'conditional'\n    };\n  }\n\n  /**\n   * Assess premade quality\n   */\n  private assessPremadeQuality(\n    premade: ComprehensiveCostAnalysis['premade'],\n    qualityPreference: CostAnalysisInput['qualityPreference']\n  ): QualityValueAssessment {\n    const tasteScore = 80; // Consistent but may lack complexity\n    const convenienceScore = 95; // Very convenient\n    const qualityScore = 85; // Generally consistent quality\n    const freshnessScore = 70; // Processed but still good\n    const consistencyScore = 95; // Very consistent\n    const valueScore = this.calculateValueScore(premade.costPerServing, tasteScore, convenienceScore);\n    const overallRating = (tasteScore + convenienceScore + qualityScore + freshnessScore + consistencyScore) / 5;\n    \n    const strengths = [\n      'Extremely convenient and time-saving',\n      'Consistent quality and taste',\n      'Professional-grade formulations',\n      'Long shelf life and storage stability',\n      'Wide variety of flavors available'\n    ];\n    \n    const weaknesses = [\n      'May contain preservatives',\n      'Less control over exact ingredients',\n      'Higher per-serving cost',\n      'Limited customization options'\n    ];\n    \n    return {\n      tasteScore,\n      convenienceScore,\n      qualityScore,\n      freshnessScore,\n      consistencyScore,\n      valueScore,\n      overallRating,\n      strengths,\n      weaknesses,\n      valueProposition: 'Ideal for busy individuals who prioritize convenience and consistent quality over customization',\n      recommendation: overallRating > 80 ? 'recommended' : 'conditional'\n    };\n  }\n\n  /**\n   * Assess hybrid quality\n   */\n  private assessHybridQuality(\n    hybrid: ComprehensiveCostAnalysis['hybrid'],\n    qualityPreference: CostAnalysisInput['qualityPreference']\n  ): QualityValueAssessment {\n    const tasteScore = 90; // Good taste with custom enhancements\n    const convenienceScore = 80; // Moderate convenience\n    const qualityScore = 88; // Good quality with premium elements\n    const freshnessScore = 85; // Fresh elements with commercial base\n    const consistencyScore = 85; // Good consistency\n    const valueScore = this.calculateValueScore(hybrid.costPerServing, tasteScore, convenienceScore);\n    const overallRating = (tasteScore + convenienceScore + qualityScore + freshnessScore + consistencyScore) / 5;\n    \n    const strengths = [\n      'Balanced approach with best of both worlds',\n      'Good value for quality ratio',\n      'Some customization possible',\n      'Moderate preparation time',\n      'Enhanced flavor complexity'\n    ];\n    \n    const weaknesses = [\n      'More complex than pure premade',\n      'Requires some culinary knowledge',\n      'Moderate equipment needs',\n      'Balance can be tricky to achieve'\n    ];\n    \n    return {\n      tasteScore,\n      convenienceScore,\n      qualityScore,\n      freshnessScore,\n      consistencyScore,\n      valueScore,\n      overallRating,\n      strengths,\n      weaknesses,\n      valueProposition: 'Perfect for those seeking a balance between convenience and quality, with room for personal customization',\n      recommendation: overallRating > 82 ? 'highly-recommended' : 'recommended'\n    };\n  }\n\n  /**\n   * Generate bulk purchasing recommendations\n   */\n  private generateBulkRecommendations(\n    syrup: PremadeSyrup,\n    batchSize: number,\n    regionalData: RegionalPricingData,\n    timeframe: CostAnalysisInput['timeframe']\n  ): BulkPurchasingRecommendation[] {\n    const recommendations: BulkPurchasingRecommendation[] = [];\n    const basePrice = syrup.regionalPricing[regionalData.region]?.price || \n                     Object.values(syrup.regionalPricing)[0].price;\n    \n    // Common bottle sizes and their bulk discount tiers\n    const bulkTiers = [\n      { size: 750, minQuantity: 1, discount: 0 },\n      { size: 1000, minQuantity: 1, discount: 0.05 },\n      { size: 2000, minQuantity: 1, discount: 0.10 },\n      { size: 4000, minQuantity: 1, discount: 0.15 }\n    ];\n    \n    bulkTiers.forEach(tier => {\n      const discountedPrice = basePrice * (1 - tier.discount);\n      const pricePerMl = discountedPrice / tier.size;\n      \n      // Calculate usage based on timeframe\n      let recommendedQuantity = 1;\n      let usageRate = 0;\n      \n      switch (timeframe) {\n        case 'immediate':\n          usageRate = batchSize / 30; // Monthly usage\n          recommendedQuantity = Math.ceil(usageRate * 1);\n          break;\n        case 'weekly':\n          usageRate = batchSize / 4; // Weekly usage\n          recommendedQuantity = Math.ceil(usageRate * 4);\n          break;\n        case 'monthly':\n          usageRate = batchSize;\n          recommendedQuantity = Math.ceil(usageRate * 1);\n          break;\n      }\n      \n      const totalPrice = discountedPrice * recommendedQuantity;\n      const savings = (basePrice * recommendedQuantity) - totalPrice;\n      const savingsPercentage = (savings / (basePrice * recommendedQuantity)) * 100;\n      \n      // Calculate break-even point\n      const breakEvenPoint = Math.ceil((savings / pricePerMl) / batchSize);\n      \n      // Assess waste risk\n      const productShelfLife = 365; // 1 year\n      const daysOfSupply = (tier.size * recommendedQuantity) / (usageRate * 250); // Assuming 250ml servings\n      const wasteRisk = daysOfSupply > productShelfLife ? 'high' : \n                       daysOfSupply > productShelfLife * 0.5 ? 'medium' : 'low';\n      \n      recommendations.push({\n        productId: syrup.id,\n        recommendedQuantity,\n        unitSize: `${tier.size}ml`,\n        unitPrice: discountedPrice,\n        totalPrice,\n        savings,\n        savingsPercentage,\n        breakEvenPoint,\n        shelfLifeConsideration: {\n          productShelfLife,\n          usageRate,\n          wasteRisk,\n          recommendation: this.getBulkRecommendation(wasteRisk, savingsPercentage)\n        },\n        storageRequirements: {\n          spaceNeeded: `${tier.size * recommendedQuantity / 1000}L`,\n          temperature: 'Cool, dry place',\n          humidity: 'Low humidity environment'\n        }\n      });\n    });\n    \n    return recommendations.sort((a, b) => b.savingsPercentage - a.savingsPercentage);\n  }\n\n  /**\n   * Determine overall recommendation\n   */\n  private determineRecommendation(\n    diy: ComprehensiveCostAnalysis['diy'],\n    premade: ComprehensiveCostAnalysis['premade'],\n    hybrid: ComprehensiveCostAnalysis['hybrid'],\n    qualityAssessment: ComprehensiveCostAnalysis['qualityAssessment'],\n    qualityPreference: CostAnalysisInput['qualityPreference']\n  ): ComprehensiveCostAnalysis['recommendation'] {\n    // Calculate weighted scores for each approach\n    const diyScore = this.calculateOverallScore(diy, qualityAssessment.diy, qualityPreference);\n    const premadeScore = this.calculateOverallScore(premade, qualityAssessment.premade, qualityPreference);\n    const hybridScore = this.calculateOverallScore(hybrid, qualityAssessment.hybrid, qualityPreference);\n    \n    const scores = [\n      { approach: 'diy' as const, score: diyScore },\n      { approach: 'premade' as const, score: premadeScore },\n      { approach: 'hybrid' as const, score: hybridScore }\n    ];\n    \n    const best = scores.reduce((prev, current) => \n      current.score > prev.score ? current : prev\n    );\n    \n    const confidence = Math.round((best.score / 100) * 100);\n    \n    const reasoning = this.generateReasoning(best.approach, scores, qualityPreference);\n    \n    const alternativeScenarios = scores\n      .filter(s => s.approach !== best.approach)\n      .map(s => ({\n        scenario: `${s.approach} approach`,\n        approach: s.approach,\n        cost: s.approach === 'diy' ? diy.totalCost : \n              s.approach === 'premade' ? premade.totalCost : hybrid.totalCost,\n        quality: s.approach === 'diy' ? qualityAssessment.diy.overallRating :\n                s.approach === 'premade' ? qualityAssessment.premade.overallRating :\n                qualityAssessment.hybrid.overallRating,\n        whenToUse: this.getScenarioUsage(s.approach)\n      }));\n    \n    return {\n      preferred: best.approach,\n      confidence,\n      reasoning,\n      alternativeScenarios\n    };\n  }\n\n  /**\n   * Generate optimization opportunities\n   */\n  private generateOptimizationOpportunities(\n    diy: ComprehensiveCostAnalysis['diy'],\n    premade: ComprehensiveCostAnalysis['premade'],\n    hybrid: ComprehensiveCostAnalysis['hybrid'],\n    targetFlavor: string\n  ): ComprehensiveCostAnalysis['optimizationOpportunities'] {\n    const costReduction: ComprehensiveCostAnalysis['optimizationOpportunities']['costReduction'] = [];\n    const qualityImprovement: ComprehensiveCostAnalysis['optimizationOpportunities']['qualityImprovement'] = [];\n    \n    // Cost reduction opportunities\n    if (diy.totalCost > premade.totalCost) {\n      costReduction.push({\n        type: 'substitution',\n        potentialSavings: diy.totalCost - premade.totalCost,\n        implementation: 'Switch to premade syrup for base flavor profile',\n        difficulty: 'easy'\n      });\n    }\n    \n    if (premade.totalCost > 15) {\n      costReduction.push({\n        type: 'bulk-purchase',\n        potentialSavings: premade.totalCost * 0.15,\n        implementation: 'Buy syrups in larger quantities for bulk discounts',\n        difficulty: 'moderate'\n      });\n    }\n    \n    // Quality improvement opportunities\n    if (hybrid.totalCost < diy.totalCost && hybrid.totalCost < premade.totalCost) {\n      qualityImprovement.push({\n        type: 'ingredient-upgrade',\n        costImpact: 2.0,\n        qualityGain: 15,\n        recommendation: 'Add premium extracts to hybrid base for enhanced complexity'\n      });\n    }\n    \n    if (diy.hiddenCosts.qualityVariation > 20) {\n      qualityImprovement.push({\n        type: 'technique-improvement',\n        costImpact: 0,\n        qualityGain: 25,\n        recommendation: 'Improve measurement precision and mixing techniques'\n      });\n    }\n    \n    return {\n      costReduction,\n      qualityImprovement\n    };\n  }\n\n  /**\n   * Analyze market trends\n   */\n  private analyzeMarketTrends(syrup: PremadeSyrup): ComprehensiveCostAnalysis['marketTrends'] {\n    const priceHistory = syrup.regionalPricing ? \n      Object.values(syrup.regionalPricing).flatMap(p => p ? [p] : []) : [];\n    \n    // Calculate price volatility\n    const prices = priceHistory.map(p => p.price);\n    const avgPrice = prices.reduce((sum, price) => sum + price, 0) / prices.length;\n    const variance = prices.reduce((sum, price) => sum + Math.pow(price - avgPrice, 2), 0) / prices.length;\n    const volatility = Math.sqrt(variance) / avgPrice;\n    \n    let priceVolatility: 'low' | 'medium' | 'high';\n    if (volatility < 0.05) priceVolatility = 'low';\n    else if (volatility < 0.15) priceVolatility = 'medium';\n    else priceVolatility = 'high';\n    \n    // Seasonal factors\n    const seasonalFactors = [\n      {\n        factor: 'Holiday season demand',\n        impact: 8,\n        timing: 'November-December'\n      },\n      {\n        factor: 'Summer beverage season',\n        impact: 12,\n        timing: 'June-August'\n      },\n      {\n        factor: 'Back-to-school period',\n        impact: 5,\n        timing: 'August-September'\n      }\n    ];\n    \n    // Future outlook\n    const recentTrend = prices[prices.length - 1] - prices[0];\n    let priceDirection: 'increasing' | 'stable' | 'decreasing';\n    if (recentTrend > 0.5) priceDirection = 'increasing';\n    else if (recentTrend < -0.5) priceDirection = 'decreasing';\n    else priceDirection = 'stable';\n    \n    return {\n      priceVolatility,\n      seasonalFactors,\n      futureOutlook: {\n        priceDirection,\n        confidence: 75,\n        timeframe: '6-12 months'\n      }\n    };\n  }\n\n  // Helper methods\n  \n  private getRegionalHourlyRate(region: string): number {\n    const rates = {\n      'US': 25,\n      'EU': 22,\n      'UK': 20,\n      'NL': 24\n    };\n    return rates[region as keyof typeof rates] || 22;\n  }\n\n  private calculateWasteFactor(diyRecipe: CostAnalysisInput['diyRecipe']): number {\n    return diyRecipe.difficulty === 'beginner' ? 10 :\n           diyRecipe.difficulty === 'intermediate' ? 5 : 2;\n  }\n\n  private calculateQualityVariation(difficulty: CostAnalysisInput['diyRecipe']['difficulty']): number {\n    return difficulty === 'beginner' ? 25 :\n           difficulty === 'intermediate' ? 15 : 8;\n  }\n\n  private getSkillRating(difficulty: CostAnalysisInput['diyRecipe']['difficulty']): number {\n    return difficulty === 'beginner' ? 2 :\n           difficulty === 'intermediate' ? 3 : 4;\n  }\n\n  private calculateSyrupNeeded(batchSize: number, dilutionRatio: string): number {\n    const [syrupPart, waterPart] = dilutionRatio.split(':').map(Number);\n    const totalParts = syrupPart + waterPart;\n    const syrupRatio = syrupPart / totalParts;\n    return (batchSize * syrupRatio) / 1000; // Convert to liters\n  }\n\n  private calculateShelfLifeValue(syrup: PremadeSyrup): number {\n    const shelfLifeMonths = syrup.usageGuide.shelfLife.includes('year') ? 12 : 6;\n    return shelfLifeMonths * 0.5; // Value per month of shelf life\n  }\n\n  private calculateConvenienceValue(diyLaborTime: number, premadeLaborTime: number): number {\n    const timeSaved = diyLaborTime - premadeLaborTime;\n    const hourlyRate = 20; // Assume $20/hour value of time\n    return (timeSaved / 60) * hourlyRate;\n  }\n\n  private calculateCustomAdditionsCost(diyRecipe: CostAnalysisInput['diyRecipe'], percentage: number): number {\n    const totalIngredientCost = diyRecipe.ingredients.reduce((sum, ing) => sum + ing.cost, 0);\n    return totalIngredientCost * percentage;\n  }\n\n  private calculateOptimizationPotential(\n    baseSyrupCost: number,\n    customAdditionsCost: number,\n    diyRecipe: CostAnalysisInput['diyRecipe']\n  ): number {\n    const totalCost = baseSyrupCost + customAdditionsCost;\n    const diyTotalCost = diyRecipe.ingredients.reduce((sum, ing) => sum + ing.cost, 0);\n    return Math.max(0, ((diyTotalCost - totalCost) / diyTotalCost) * 100);\n  }\n\n  private calculateValueScore(costPerServing: number, tasteScore: number, convenienceScore: number): number {\n    // Higher score for better taste/convenience and lower cost\n    const costScore = Math.max(0, 100 - (costPerServing * 10));\n    const qualityScore = (tasteScore + convenienceScore) / 2;\n    return (costScore * 0.4 + qualityScore * 0.6);\n  }\n\n  private calculateOverallScore(\n    costData: any,\n    qualityAssessment: QualityValueAssessment,\n    qualityPreference: CostAnalysisInput['qualityPreference']\n  ): number {\n    const costScore = Math.max(0, 100 - (costData.costPerServing * 20));\n    const qualityWeight = qualityPreference === 'premium' ? 0.8 :\n                         qualityPreference === 'budget' ? 0.4 : 0.6;\n    return costScore * (1 - qualityWeight) + qualityAssessment.overallRating * qualityWeight;\n  }\n\n  private generateReasoning(\n    preferred: 'diy' | 'premade' | 'hybrid',\n    scores: Array<{ approach: 'diy' | 'premade' | 'hybrid'; score: number }>,\n    qualityPreference: CostAnalysisInput['qualityPreference']\n  ): string[] {\n    const reasoning: string[] = [];\n    \n    switch (preferred) {\n      case 'diy':\n        reasoning.push('Best for users who prioritize fresh, natural ingredients');\n        reasoning.push('Offers maximum customization and ingredient control');\n        reasoning.push('Ideal for enthusiasts with time and culinary skills');\n        break;\n      case 'premade':\n        reasoning.push('Most convenient option with consistent quality');\n        reasoning.push('Time-saving solution for busy lifestyles');\n        reasoning.push('Professional-grade formulations available');\n        break;\n      case 'hybrid':\n        reasoning.push('Balanced approach offering both convenience and customization');\n        reasoning.push('Good value proposition for quality and cost');\n        reasoning.push('Optimal for users wanting enhanced flavor complexity');\n        break;\n    }\n    \n    if (qualityPreference === 'premium') {\n      reasoning.push('Premium quality focus justifies the approach choice');\n    } else if (qualityPreference === 'budget') {\n      reasoning.push('Cost optimization is prioritized in this recommendation');\n    }\n    \n    return reasoning;\n  }\n\n  private getScenarioUsage(approach: 'diy' | 'premade' | 'hybrid'): string {\n    switch (approach) {\n      case 'diy':\n        return 'Best for special occasions, ingredient experimentation, and when time is not a constraint';\n      case 'premade':\n        return 'Ideal for daily consumption, office environments, and when convenience is paramount';\n      case 'hybrid':\n        return 'Perfect for entertaining, creating signature drinks, and achieving specific flavor profiles';\n    }\n  }\n\n  private getBulkRecommendation(wasteRisk: 'low' | 'medium' | 'high', savingsPercentage: number): string {\n    if (wasteRisk === 'high' && savingsPercentage > 10) {\n      return 'Consider smaller quantities to avoid waste despite potential savings';\n    } else if (wasteRisk === 'low' && savingsPercentage > 15) {\n      return 'Excellent bulk opportunity with minimal waste risk';\n    } else {\n      return 'Good balance of savings and practical usage';\n    }\n  }\n\n  /**\n   * Get ingredient cost\n   */\n  public getIngredientCost(ingredientId: string): number {\n    return this.ingredientCosts.get(ingredientId) || 0;\n  }\n\n  /**\n   * Get equipment cost\n   */\n  public getEquipmentCost(equipmentId: string): number {\n    return this.equipmentCosts.get(equipmentId) || 0;\n  }\n\n  /**\n   * Get regional pricing data\n   */\n  public getRegionalPricing(region: string): RegionalPricingData | undefined {\n    return this.regionalPricing.get(region);\n  }\n\n  /**\n   * Update ingredient costs\n   */\n  public updateIngredientCost(ingredientId: string, newCost: number): void {\n    this.ingredientCosts.set(ingredientId, newCost);\n  }\n\n  /**\n   * Update equipment costs\n   */\n  public updateEquipmentCost(equipmentId: string, newCost: number): void {\n    this.equipmentCosts.set(equipmentId, newCost);\n  }\n\n  /**\n   * Add regional pricing data\n   */\n  public addRegionalPricing(pricing: RegionalPricingData): void {\n    this.regionalPricing.set(pricing.region, pricing);\n  }\n}"
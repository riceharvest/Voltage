/**
 * Syrup System Validation Tests\n * \n * Comprehensive test suite for validating syrup compatibility, dilution\n * accuracy, cost calculations, and taste profile matching algorithms.\n * \n * @group syrup-system\n * @group validation\n */\n\nimport { describe, test, expect, beforeEach, vi } from 'vitest';\nimport { SyrupValidationService } from '@/lib/syrup-validation-service';\nimport { PremadeSyrup } from '@/lib/types';\nimport { syrupDatabase } from '@/data/syrups';\n\n// Mock data for testing\nconst mockSyrup: PremadeSyrup = {\n  id: 'torani-vanilla-classic',\n  brand: 'Torani',\n  name: 'Torani Classic Vanilla Syrup',\n  category: 'flavor',\n  concentration: 'concentrate',\n  dilutionRatio: '1:1',\n  compatibleFlavors: ['vanilla', 'cream', 'coffee', 'dessert', 'sweet'],\n  regionalPricing: {\n    US: { price: 12.99, currency: 'USD', retailer: 'Amazon', availability: 'in-stock' },\n    EU: { price: 11.49, currency: 'EUR', retailer: 'Amazon EU', availability: 'in-stock' }\n  },\n  availability: 'in-stock',\n  rating: 4.7,\n  reviewCount: 3241,\n  description: 'Rich, smooth vanilla syrup with authentic Madagascar vanilla flavor.',\n  tasteProfile: {\n    sweetness: 'high',\n    intensity: 'strong',\n    notes: ['madagascar-vanilla', 'creamy', 'smooth', 'rich', 'authentic']\n  },\n  usageGuide: {\n    recommendedRatio: '1:1',\n    maxDaily: 30,\n    storage: 'Room temperature, away from direct sunlight',\n    shelfLife: '2 years unopened, 1 year after opening'\n  },\n  amazonAsins: {\n    US: 'B000KT5Y2W',\n    EU: 'B07Y8RTEST'\n  }\n};\n\ndescribe('SyrupValidationService', () => {\n  let validationService: SyrupValidationService;\n\n  beforeEach(() => {\n    validationService = new SyrupValidationService();\n  });\n\n  describe('validateSyrupCompatibility', () => {\n    test('should validate compatible syrup correctly', async () => {\n      const result = await validationService.validateSyrupCompatibility(\n        mockSyrup,\n        'vanilla coffee'\n      );\n\n      expect(result).toBeDefined();\n      expect(result.overallScore).toBeGreaterThanOrEqual(0);\n      expect(result.overallScore).toBeLessThanOrEqual(100);\n      expect(result.flavorMatch).toBeGreaterThanOrEqual(0);\n      expect(result.tasteAlignment).toBeGreaterThanOrEqual(0);\n      expect(result.qualityScore).toBeGreaterThanOrEqual(0);\n      expect(result.dilutionCompatibility).toBeGreaterThanOrEqual(0);\n      expect(Array.isArray(result.issues)).toBe(true);\n    });\n\n    test('should detect low flavor compatibility', async () => {\n      const result = await validationService.validateSyrupCompatibility(\n        mockSyrup,\n        'peppermint chocolate'\n      );\n\n      const lowCompatibilityIssues = result.issues.filter(\n        issue => issue.code === 'LOW_FLAVOR_MATCH'\n      );\n\n      if (result.flavorMatch < 60) {\n        expect(lowCompatibilityIssues.length).toBeGreaterThan(0);\n      }\n    });\n\n    test('should detect quality issues', async () => {\n      const lowQualitySyrup = {\n        ...mockSyrup,\n        rating: 2.0,\n        reviewCount: 50\n      };\n\n      const result = await validationService.validateSyrupCompatibility(\n        lowQualitySyrup,\n        'vanilla'\n      );\n\n      const qualityIssues = result.issues.filter(\n        issue => issue.code === 'LOW_QUALITY_SCORE'\n      );\n\n      expect(result.qualityScore).toBeLessThan(60);\n      expect(qualityIssues.length).toBeGreaterThan(0);\n    });\n\n    test('should handle various flavor profiles', async () => {\n      const testFlavors = [\n        'vanilla cream',\n        'caramel sweet',\n        'citrus tart',\n        'coffee bitter',\n        'chocolate rich'\n      ];\n\n      for (const flavor of testFlavors) {\n        const result = await validationService.validateSyrupCompatibility(\n          mockSyrup,\n          flavor\n        );\n\n        expect(result.overallScore).toBeGreaterThanOrEqual(0);\n        expect(result.overallScore).toBeLessThanOrEqual(100);\n        expect(result.flavorMatch).toBeGreaterThanOrEqual(0);\n      }\n    });\n  });\n\n  describe('validateDilutionAccuracy', () => {\n    test('should validate correct dilution ratio', () => {\n      const result = validationService.validateDilutionAccuracy(\n        mockSyrup,\n        '1:1',\n        250\n      );\n\n      expect(result).toBeDefined();\n      expect(result.ratioAccuracy).toBe(100);\n      expect(result.overallAccuracy).toBeGreaterThanOrEqual(0);\n      expect(result.overallAccuracy).toBeLessThanOrEqual(100);\n    });\n\n    test('should detect imprecise dilution ratios', () => {\n      const result = validationService.validateDilutionAccuracy(\n        mockSyrup,\n        '1:10',\n        250\n      );\n\n      const impreciseRatioIssues = result.issues.filter(\n        issue => issue.code === 'IMPRE_CISE_RATIO'\n      );\n\n      if (result.ratioAccuracy < 80) {\n        expect(impreciseRatioIssues.length).toBeGreaterThan(0);\n      }\n    });\n\n    test('should validate volume accuracy', () => {\n      const result1 = validationService.validateDilutionAccuracy(\n        mockSyrup,\n        '1:3',\n        250\n      );\n\n      const result2 = validationService.validateDilutionAccuracy(\n        mockSyrup,\n        '1:3',\n        50\n      );\n\n      expect(result1.volumeAccuracy).toBeGreaterThanOrEqual(result2.volumeAccuracy);\n    });\n\n    test('should handle various concentration types', () => {\n      const testSyrups = [\n        { ...mockSyrup, concentration: 'concentrate' as const },\n        { ...mockSyrup, concentration: 'ready-to-drink' as const },\n        { ...mockSyrup, concentration: 'powder' as const }\n      ];\n\n      for (const syrup of testSyrups) {\n        const result = validationService.validateDilutionAccuracy(\n          syrup,\n          '1:3',\n          250\n        );\n\n        expect(result.concentrationCorrectness).toBeGreaterThanOrEqual(0);\n        expect(result.concentrationCorrectness).toBeLessThanOrEqual(100);\n      }\n    });\n  });\n\n  describe('validateCostCalculations', () => {\n    test('should validate cost analysis structure', async () => {\n      // Create a mock cost analysis\n      const mockCostAnalysis = {\n        diy: {\n          totalCost: 45.00,\n          costPerServing: 2.25,\n          ingredientCost: 30.00,\n          laborCost: 10.00,\n          equipmentCost: 5.00,\n          wasteCost: 0.00\n        },\n        premade: {\n          totalCost: 60.00,\n          costPerServing: 3.00,\n          syrupCost: 50.00,\n          shippingCost: 8.00,\n          timeSavingsValue: 2.00,\n          conveniencePremium: 0.00\n        },\n        hybrid: {\n          totalCost: 52.50,\n          costPerServing: 2.63,\n          syrupCost: 35.00,\n          additiveCost: 12.50,\n          laborCost: 5.00,\n          equipmentCost: 0.00\n        },\n        recommendation: {\n          preferred: 'hybrid',\n          confidence: 85,\n          reasoning: [\n            'Best balance of cost and quality',\n            'Moderate preparation time',\n            'Good value for money'\n          ],\n          alternativeScenarios: []\n        },\n        qualityAssessment: {\n          diy: {\n            overallRating: 90,\n            tasteScore: 85,\n            convenienceScore: 40,\n            freshnessScore: 95,\n            consistencyScore: 60,\n            recommendation: 'recommended'\n          },\n          premade: {\n            overallRating: 75,\n            tasteScore: 80,\n            convenienceScore: 95,\n            freshnessScore: 70,\n            consistencyScore: 90,\n            recommendation: 'recommended'\n          },\n          hybrid: {\n            overallRating: 85,\n            tasteScore: 85,\n            convenienceScore: 70,\n            freshnessScore: 80,\n            consistencyScore: 85,\n            recommendation: 'highly-recommended'\n          }\n        },\n        costAnalysis: {\n          costComparison: 'hybrid offers best value',\n          breakEvenPoint: 15,\n          volumeDiscountThreshold: 50,\n          totalSavings: 7.50\n        },\n        optimizationOpportunities: {\n          costReduction: [\n            {\n              category: 'bulk-purchase',\n              description: 'Buy syrups in bulk for 15% savings',\n              potentialSavings: 5.25,\n              implementationDifficulty: 'low'\n            }\n          ],\n          qualityImprovement: []\n        },\n        marketTrends: {\n          priceVolatility: 'moderate',\n          seasonalFactors: [\n            { month: 'December', impact: 10 },\n            { month: 'January', impact: -5 }\n          ],\n          futureOutlook: 'Prices expected to remain stable'\n        },\n        regionalPricing: {\n          taxRate: 0.21,\n          shippingCost: 5.99,\n          availabilityFactor: 0.95\n        }\n      };\n\n      const result = await validationService.validateCostCalculations(mockCostAnalysis);\n\n      expect(result).toBeDefined();\n      expect(result.pricingAccuracy).toBeGreaterThanOrEqual(0);\n      expect(result.calculationCorrectness).toBeGreaterThanOrEqual(0);\n      expect(result.regionalAccuracy).toBeGreaterThanOrEqual(0);\n      expect(result.comparisonValidity).toBeGreaterThanOrEqual(0);\n      expect(result.overallAccuracy).toBeGreaterThanOrEqual(0);\n      expect(result.overallAccuracy).toBeLessThanOrEqual(100);\n    });\n\n    test('should detect calculation errors', async () => {\n      const invalidCostAnalysis = {\n        ...mockCostAnalysis,\n        diy: {\n          ...mockCostAnalysis.diy,\n          totalCost: -10 // Invalid negative cost\n        }\n      };\n\n      const result = await validationService.validateCostCalculations(invalidCostAnalysis);\n\n      expect(result.calculationCorrectness).toBeLessThan(90);\n    });\n  });\n\n  describe('validateTasteProfileMatching', () => {\n    test('should validate taste profile alignment', async () => {\n      const result = await validationService.validateTasteProfileMatching(\n        mockSyrup,\n        'rich vanilla dessert'\n      );\n\n      expect(result).toBeDefined();\n      expect(result.isValid).toBeBoolean();\n      expect(result.score).toBeGreaterThanOrEqual(0);\n      expect(result.score).toBeLessThanOrEqual(100);\n      expect(result.confidence).toBeGreaterThanOrEqual(0);\n      expect(result.confidence).toBeLessThanOrEqual(1);\n      expect(Array.isArray(result.recommendations)).toBe(true);\n    });\n\n    test('should detect flavor notes misalignment', async () => {\n      const result = await validationService.validateTasteProfileMatching(\n        mockSyrup,\n        'citrus tart sour'\n      );\n\n      const alignmentIssues = result.issues.filter(\n        issue => issue.code === 'LIMITED_FLAVOR_ALIGNMENT'\n      );\n\n      if (result.score < 60) {\n        expect(alignmentIssues.length).toBeGreaterThan(0);\n      }\n    });\n\n    test('should analyze sweetness compatibility', async () => {\n      const sweetSyrup = {\n        ...mockSyrup,\n        tasteProfile: {\n          ...mockSyrup.tasteProfile,\n          sweetness: 'very-high'\n        }\n      };\n\n      const result = await validationService.validateTasteProfileMatching(\n        sweetSyrup,\n        'tart lemon sour'\n      );\n\n      const sweetnessIssues = result.issues.filter(\n        issue => issue.code === 'SWEETNESS_MISMATCH'\n      );\n\n      if (result.score < 70) {\n        expect(sweetnessIssues.length).toBeGreaterThan(0);\n      }\n    });\n  });\n\n  describe('runComprehensiveValidation', () => {\n    test('should run complete validation suite', async () => {\n      const result = await validationService.runComprehensiveValidation(\n        mockSyrup,\n        'vanilla coffee',\n        '1:1',\n        250\n      );\n\n      expect(result).toBeDefined();\n      expect(result.compatibility).toBeDefined();\n      expect(result.dilution).toBeDefined();\n      expect(result.tasteProfile).toBeDefined();\n      expect(result.overallScore).toBeGreaterThanOrEqual(0);\n      expect(result.overallScore).toBeLessThanOrEqual(100);\n      expect(Array.isArray(result.summary)).toBe(true);\n    });\n\n    test('should handle missing cost analysis', async () => {\n      const result = await validationService.runComprehensiveValidation(\n        mockSyrup,\n        'vanilla coffee',\n        '1:1',\n        250\n      );\n\n      expect(result.cost).toBeUndefined();\n    });\n\n    test('should include cost validation when provided', async () => {\n      const mockCostAnalysis = {\n        diy: {\n          totalCost: 45.00,\n          costPerServing: 2.25,\n          ingredientCost: 30.00,\n          laborCost: 10.00,\n          equipmentCost: 5.00,\n          wasteCost: 0.00\n        },\n        premade: {\n          totalCost: 60.00,\n          costPerServing: 3.00,\n          syrupCost: 50.00,\n          shippingCost: 8.00,\n          timeSavingsValue: 2.00,\n          conveniencePremium: 0.00\n        },\n        hybrid: {\n          totalCost: 52.50,\n          costPerServing: 2.63,\n          syrupCost: 35.00,\n          additiveCost: 12.50,\n          laborCost: 5.00,\n          equipmentCost: 0.00\n        },\n        recommendation: {\n          preferred: 'hybrid',\n          confidence: 85,\n          reasoning: ['Best balance of cost and quality'],\n          alternativeScenarios: []\n        },\n        qualityAssessment: {\n          diy: {\n            overallRating: 90,\n            tasteScore: 85,\n            convenienceScore: 40,\n            freshnessScore: 95,\n            consistencyScore: 60,\n            recommendation: 'recommended'\n          },\n          premade: {\n            overallRating: 75,\n            tasteScore: 80,\n            convenienceScore: 95,\n            freshnessScore: 70,\n            consistencyScore: 90,\n            recommendation: 'recommended'\n          },\n          hybrid: {\n            overallRating: 85,\n            tasteScore: 85,\n            convenienceScore: 70,\n            freshnessScore: 80,\n            consistencyScore: 85,\n            recommendation: 'highly-recommended'\n          }\n        },\n        costAnalysis: {\n          costComparison: 'hybrid offers best value',\n          breakEvenPoint: 15,\n          volumeDiscountThreshold: 50,\n          totalSavings: 7.50\n        },\n        optimizationOpportunities: {\n          costReduction: [],\n          qualityImprovement: []\n        },\n        marketTrends: {\n          priceVolatility: 'moderate',\n          seasonalFactors: [],\n          futureOutlook: 'Prices expected to remain stable'\n        },\n        regionalPricing: {\n          taxRate: 0.21,\n          shippingCost: 5.99,\n          availabilityFactor: 0.95\n        }\n      };\n\n      const result = await validationService.runComprehensiveValidation(\n        mockSyrup,\n        'vanilla coffee',\n        '1:1',\n        250,\n        mockCostAnalysis\n      );\n\n      expect(result.cost).toBeDefined();\n      expect(result.cost?.pricingAccuracy).toBeGreaterThanOrEqual(0);\n    });\n  });\n\n  describe('Integration with real syrup database', () => {\n    test('should validate all syrups in database', async () => {\n      const testFlavors = ['vanilla', 'caramel', 'coffee', 'fruit'];\n      const validationResults = [];\n\n      for (const flavor of testFlavors) {\n        const compatibleSyrups = syrupDatabase.filter(syrup =>\n          syrup.compatibleFlavors.some(f => \n            f.toLowerCase().includes(flavor) || flavor.includes(f.toLowerCase())\n          )\n        );\n\n        for (const syrup of compatibleSyrups.slice(0, 2)) { // Test first 2 compatible syrups\n          const result = await validationService.validateSyrupCompatibility(syrup, flavor);\n          validationResults.push({ syrup: syrup.name, flavor, score: result.overallScore });\n        }\n      }\n\n      expect(validationResults.length).toBeGreaterThan(0);\n      validationResults.forEach(result => {\n        expect(result.score).toBeGreaterThanOrEqual(0);\n        expect(result.score).toBeLessThanOrEqual(100);\n      });\n    });\n\n    test('should validate dilution accuracy across syrup types', () => {\n      const testVolumes = [100, 250, 500, 1000];\n      const testRatios = ['1:1', '1:2', '1:3', '1:4'];\n\n      for (const syrup of syrupDatabase.slice(0, 5)) {\n        for (const volume of testVolumes) {\n          for (const ratio of testRatios) {\n            const result = validationService.validateDilutionAccuracy(syrup, ratio, volume);\n            \n            expect(result.ratioAccuracy).toBeGreaterThanOrEqual(0);\n            expect(result.volumeAccuracy).toBeGreaterThanOrEqual(0);\n            expect(result.concentrationCorrectness).toBeGreaterThanOrEqual(0);\n            expect(result.overallAccuracy).toBeGreaterThanOrEqual(0);\n          }\n        }\n      }\n    });\n  });\n\n  describe('Edge cases and error handling', () => {\n    test('should handle empty syrup data gracefully', async () => {\n      const emptySyrup = {} as PremadeSyrup;\n\n      const result = await validationService.validateSyrupCompatibility(\n        emptySyrup,\n        'vanilla'\n      );\n\n      expect(result).toBeDefined();\n      expect(result.overallScore).toBeGreaterThanOrEqual(0);\n    });\n\n    test('should handle extreme dilution ratios', () => {\n      const extremeRatios = ['1:50', '1:100', '5:1', '10:1'];\n\n      for (const ratio of extremeRatios) {\n        const result = validationService.validateDilutionAccuracy(\n          mockSyrup,\n          ratio,\n          250\n        );\n\n        expect(result.ratioAccuracy).toBeLessThan(100);\n        expect(result.overallAccuracy).toBeLessThanOrEqual(100);\n      }\n    });\n\n    test('should handle extreme volumes', () => {\n      const extremeVolumes = [10, 2000, 5000];\n\n      for (const volume of extremeVolumes) {\n        const result = validationService.validateDilutionAccuracy(\n          mockSyrup,\n          '1:3',\n          volume\n        );\n\n        expect(result.volumeAccuracy).toBeLessThan(100);\n      }\n    });\n\n    test('should handle malformed ratios gracefully', () => {\n      const malformedRatios = ['invalid', '1:', ':1', 'abc:def', ''];\n\n      for (const ratio of malformedRatios) {\n        const result = validationService.validateDilutionAccuracy(\n          mockSyrup,\n          ratio,\n          250\n        );\n\n        expect(result).toBeDefined();\n        expect(result.ratioAccuracy).toBeLessThan(100);\n      }\n    });\n  });\n\n  describe('Performance and scalability', () => {\n    test('should validate multiple syrups efficiently', async () => {\n      const startTime = Date.now();\n      const validationPromises = syrupDatabase.slice(0, 10).map(syrup =>\n        validationService.validateSyrupCompatibility(syrup, 'vanilla')\n      );\n\n      const results = await Promise.all(validationPromises);\n      const endTime = Date.now();\n\n      expect(results).toHaveLength(10);\n      expect(endTime - startTime).toBeLessThan(5000); // Should complete within 5 seconds\n    });\n\n    test('should handle concurrent validation requests', async () => {\n      const concurrentRequests = 5;\n      const requests = Array.from({ length: concurrentRequests }, (_, i) =>\n        validationService.runComprehensiveValidation(\n          mockSyrup,\n          `flavor${i}`,\n          '1:1',\n          250\n        )\n      );\n\n      const results = await Promise.all(requests);\n\n      expect(results).toHaveLength(concurrentRequests);\n      results.forEach(result => {\n        expect(result.overallScore).toBeGreaterThanOrEqual(0);\n        expect(result.overallScore).toBeLessThanOrEqual(100);\n      });\n    });\n  });\n});\n\n// Additional test data for comprehensive testing\nexport const testData = {\n  vanillaSyrup: mockSyrup,\n  fruitSyrup: {\n    ...mockSyrup,\n    id: 'davinci-raspberry-gourmet',\n    brand: 'DaVinci',\n    name: 'DaVinci Gourmet Raspberry Syrup',\n    category: 'fruit',\n    compatibleFlavors: ['raspberry', 'berry', 'fruit', 'tart', 'vibrant'],\n    tasteProfile: {\n      sweetness: 'medium',\n      intensity: 'strong',\n      notes: ['raspberry', 'tart', 'fruity', 'vibrant', 'natural']\n    }\n  },\n  spiceSyrup: {\n    ...mockSyrup,\n    id: 'torani-pumpkin-spice',\n    brand: 'Torani',\n    name: 'Torani Pumpkin Spice Syrup',\n    category: 'spice',\n    compatibleFlavors: ['pumpkin', 'spice', 'autumn', 'warm', 'cinnamon'],\n    tasteProfile: {\n      sweetness: 'medium',\n      intensity: 'strong',\n      notes: ['pumpkin', 'cinnamon', 'nutmeg', 'clove', 'warm', 'autumn']\n    }\n  }\n};"
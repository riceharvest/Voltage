/**
 * Performance Monitoring and Analytics System
 * 
 * This module provides comprehensive performance monitoring, metrics collection,
 * alerting, and optimization recommendations for the energy drink application.
 * 
 * Key Features:
 * - Real-time performance metrics collection
 * - Intelligent alerting based on thresholds
 * - Cache performance monitoring
 * - API response time tracking
 * - Automatic optimization recommendations
 * - Background monitoring with configurable intervals
 * 
 * @module performance-monitor
 * @author Energy Drink App Team
 * @since 2.0.0
 */

import { enhancedCache } from './enhanced-cache';
import { logger } from './logger';
import { optimizedDataService } from './optimized-data-service';

/**
 * Performance Monitoring Class
 * 
 * Collects, analyzes, and reports on application performance metrics.
 * Provides real-time monitoring with configurable alerting and recommendations.
 * 
 * @class PerformanceMonitor
 */
class PerformanceMonitor {
  /** Metrics storage with metric name as key and array of values */
  private metrics = new Map<string, number[]>();
  /** Performance alerts generated by monitoring */
  private alerts: PerformanceAlert[] = [];
  /** Background monitoring interval */
  private monitoringInterval: NodeJS.Timeout | null = null;

  /**
   * Creates a performance monitor instance and starts background monitoring
   */
  constructor() {
    this.startMonitoring();
  }

  /**
   * Starts automatic performance monitoring
   * Collects metrics and checks thresholds every 30 seconds
   * 
   * @private
   */
  private startMonitoring(): void {
    // Monitor performance every 30 seconds
    this.monitoringInterval = setInterval(async () => {
      await this.collectMetrics();
      await this.checkPerformanceThresholds();
    }, 30 * 1000);
  }

  /**
   * Records a performance metric with optional tags
   * Tracks response times, cache hit rates, memory usage, etc.
   * Automatically maintains rolling window of last 100 values per metric
   * 
   * @param name - Metric name (e.g., 'api.responseTime', 'cache.hitRate')
   * @param value - Metric value (typically in milliseconds or percentage)
   * @param tags - Optional tags for metric categorization
   * @example
   * ```typescript
   * performanceMonitor.recordMetric('api.responseTime', 250, { endpoint: '/api/flavors' });
   * performanceMonitor.recordMetric('cache.hitRate', 85.5, { level: 'memory' });
   * ```
   */
  recordMetric(name: string, value: number, tags?: Record<string, string>): void {
    const key = this.getMetricKey(name, tags);
    
    if (!this.metrics.has(key)) {
      this.metrics.set(key, []);
    }
    
    const values = this.metrics.get(key)!;
    values.push(value);
    
    // Keep only last 100 values per metric
    if (values.length > 100) {
      values.shift();
    }

    // Log slow operations
    if (value > 5000) { // 5 seconds
      logger.warn(`Slow operation detected: ${name}`, {
        value,
        tags,
        threshold: 5000
      });
    }
  }

  /**
   * Generates a unique metric key including tags for categorization
   * 
   * @param name - Base metric name
   * @param tags - Optional tags for categorization
   * @returns Unique metric key with tags
   * @private
   */
  private getMetricKey(name: string, tags?: Record<string, string>): string {
    if (!tags) return name;
    const tagString = Object.entries(tags)
      .sort(([a], [b]) => a.localeCompare(b))
      .map(([k, v]) => `${k}:${v}`)
      .join(',');
    return `${name}[${tagString}]`;
  }

  /**
   * Gets performance statistics for a specific metric or all metrics
   * Calculates statistical measures including percentiles for performance analysis
   * 
   * @param metricName - Specific metric to get stats for (optional)
   * @returns Performance statistics object or record of all stats
   * @example
   * ```typescript
   * const apiStats = performanceMonitor.getStats('api.responseTime');
   * // Returns: { count: 150, avg: 245, min: 120, max: 1200, p50: 200, p95: 450, p99: 890 }
   * ```
   */
  getStats(metricName?: string): PerformanceStats {
    if (metricName) {
      const values = this.metrics.get(metricName) || [];
      return this.calculateStats(values);
    }

    const allStats: Record<string, PerformanceStats> = {};
    for (const [key, values] of this.metrics.entries()) {
      allStats[key] = this.calculateStats(values);
    }
    return allStats;
  }

  /**
   * Calculates statistical measures from an array of values
   * Includes count, average, min, max, and percentiles (50th, 95th, 99th)
   * 
   * @param values - Array of numeric values to analyze
   * @returns Statistical measures
   * @private
   */
  private calculateStats(values: number[]): PerformanceStats {
    if (values.length === 0) {
      return {
        count: 0,
        avg: 0,
        min: 0,
        max: 0,
        p50: 0,
        p95: 0,
        p99: 0
      };
    }

    const sorted = [...values].sort((a, b) => a - b);
    const count = values.length;
    const sum = values.reduce((a, b) => a + b, 0);

    return {
      count,
      avg: Math.round(sum / count * 100) / 100,
      min: sorted[0],
      max: sorted[count - 1],
      p50: sorted[Math.floor(count * 0.5)],
      p95: sorted[Math.floor(count * 0.95)],
      p99: sorted[Math.floor(count * 0.99)]
    };
  }

  /**
   * Monitors cache performance metrics
   * Tracks hit rates, memory usage, response times, and evictions
   * 
   * @returns Cache performance metrics
   * @example
   * ```typescript
   * const cachePerf = await performanceMonitor.monitorCachePerformance();
   * // Returns: { hitRate: 85.2, memoryUsageMB: 12.5, avgResponseTime: 5.2, ... }
   * ```
   */
  async monitorCachePerformance(): Promise<CachePerformanceMetrics> {
    try {
      const cacheMetrics = await enhancedCache.getMetrics();
      
      const cachePerf: CachePerformanceMetrics = {
        hitRate: cacheMetrics.memory?.hitRate || 0,
        memoryUsageMB: cacheMetrics.memory?.memoryUsageMB || 0,
        avgResponseTime: cacheMetrics.memory?.avgResponseTime || 0,
        totalRequests: (cacheMetrics.memory?.hits || 0) + (cacheMetrics.memory?.misses || 0),
        evictions: cacheMetrics.memory?.evictions || 0
      };

      this.recordMetric('cache.hitRate', cachePerf.hitRate, { level: 'memory' });
      this.recordMetric('cache.memoryUsage', cachePerf.memoryUsageMB, { level: 'memory' });
      this.recordMetric('cache.responseTime', cachePerf.avgResponseTime, { level: 'memory' });

      return cachePerf;
    } catch (error) {
      logger.error('Cache performance monitoring error', error);
      return {
        hitRate: 0,
        memoryUsageMB: 0,
        avgResponseTime: 0,
        totalRequests: 0,
        evictions: 0
      };
    }
  }

  /**
   * Monitors API performance metrics
   * Tracks response times, cache hit rates, memory usage, and background sync status
   * 
   * @returns API performance metrics
   * @example
   * ```typescript
   * const apiPerf = await performanceMonitor.monitorApiPerformance();
   * // Returns: { avgResponseTime: 180, cacheHitRate: 78.5, memoryUsage: 45.2, ... }
   * ```
   */
  async monitorApiPerformance(): Promise<ApiPerformanceMetrics> {
    try {
      const dataServiceMetrics = await optimizedDataService.getPerformanceMetrics();
      
      const apiPerf: ApiPerformanceMetrics = {
        avgResponseTime: dataServiceMetrics.avgResponseTime,
        cacheHitRate: dataServiceMetrics.cacheHitRate,
        memoryUsage: dataServiceMetrics.memoryUsage,
        backgroundSyncStatus: dataServiceMetrics.backgroundSyncStatus
      };

      this.recordMetric('api.responseTime', apiPerf.avgResponseTime);
      this.recordMetric('api.cacheHitRate', apiPerf.cacheHitRate);
      this.recordMetric('api.memoryUsage', apiPerf.memoryUsage);

      return apiPerf;
    } catch (error) {
      logger.error('API performance monitoring error', error);
      return {
        avgResponseTime: 0,
        cacheHitRate: 0,
        memoryUsage: 0,
        backgroundSyncStatus: 'unknown'
      };
    }
  }

  /**
   * Collects comprehensive metrics from all systems
   * Runs cache and API monitoring in parallel for efficiency
   * Stores combined metrics in cache for external access
   * 
   * @private
   */
  private async collectMetrics(): Promise<void> {
    try {
      const [cachePerf, apiPerf] = await Promise.all([
        this.monitorCachePerformance(),
        this.monitorApiPerformance()
      ]);

      // Store combined metrics
      const combinedMetrics = {
        timestamp: Date.now(),
        cache: cachePerf,
        api: apiPerf
      };

      await enhancedCache.set('performance:metrics', combinedMetrics, 300); // 5 minutes
    } catch (error) {
      logger.error('Metrics collection error', error);
    }
  }

  /**
   * Checks performance thresholds and generates alerts
   * Monitors cache hit rates, memory usage, and API response times
   * Automatically generates warnings and errors based on thresholds
   * 
   * @private
   */
  private async checkPerformanceThresholds(): Promise<void> {
    const cachePerf = await this.monitorCachePerformance();
    const apiPerf = await this.monitorApiPerformance();
    const stats = this.getStats();

    const alerts: PerformanceAlert[] = [];

    // Cache hit rate alerts
    if (cachePerf.hitRate < 50) {
      alerts.push({
        type: 'cache_hit_rate_low',
        severity: 'warning',
        message: `Cache hit rate is low: ${cachePerf.hitRate.toFixed(1)}%`,
        value: cachePerf.hitRate,
        threshold: 50,
        timestamp: Date.now()
      });
    }

    // Memory usage alerts
    if (cachePerf.memoryUsageMB > 40) {
      alerts.push({
        type: 'memory_usage_high',
        severity: 'warning',
        message: `Memory usage is high: ${cachePerf.memoryUsageMB.toFixed(1)}MB`,
        value: cachePerf.memoryUsageMB,
        threshold: 40,
        timestamp: Date.now()
      });
    }

    // Response time alerts
    const apiResponseTime = stats['api.responseTime'];
    if (apiResponseTime && apiResponseTime.p95 > 2000) {
      alerts.push({
        type: 'response_time_high',
        severity: 'error',
        message: `High API response time: P95=${apiResponseTime.p95}ms`,
        value: apiResponseTime.p95,
        threshold: 2000,
        timestamp: Date.now()
      });
    }

    // Store new alerts
    this.alerts.push(...alerts);
    
    // Keep only recent alerts (last 100)
    if (this.alerts.length > 100) {
      this.alerts = this.alerts.slice(-100);
    }

    // Log critical alerts
    alerts.forEach(alert => {
      if (alert.severity === 'error') {
        logger.error(`Performance Alert: ${alert.message}`, alert);
      } else {
        logger.warn(`Performance Warning: ${alert.message}`, alert);
      }
    });
  }

  /**
   * Generates a comprehensive performance report
   * Includes overall health assessment, detailed statistics, recent alerts, and recommendations
   * 
   * @returns Complete performance report
   * @example
   * ```typescript
   * const report = await performanceMonitor.getPerformanceReport();
   * // Returns comprehensive report with health score, stats, alerts, and recommendations
   * ```
   */
  async getPerformanceReport(): Promise<PerformanceReport> {
    const cachePerf = await this.monitorCachePerformance();
    const apiPerf = await this.monitorApiPerformance();
    const stats = this.getStats();

    return {
      timestamp: Date.now(),
      summary: {
        overallHealth: this.calculateOverallHealth(cachePerf, apiPerf),
        cache: cachePerf,
        api: apiPerf
      },
      detailedStats: stats,
      recentAlerts: this.alerts.slice(-10),
      recommendations: this.generateRecommendations(cachePerf, apiPerf)
    };
  }

  /**
   * Calculates overall application health score based on performance metrics
   * Provides a simple health classification for quick assessment
   * 
   * @param cachePerf - Cache performance metrics
   * @param apiPerf - API performance metrics
   * @returns Health classification: 'excellent', 'good', 'fair', or 'poor'
   * @private
   */
  private calculateOverallHealth(cachePerf: CachePerformanceMetrics, apiPerf: ApiPerformanceMetrics): string {
    let score = 100;

    // Deduct points for poor metrics
    if (cachePerf.hitRate < 70) score -= 20;
    if (cachePerf.hitRate < 50) score -= 30;
    
    if (cachePerf.memoryUsageMB > 30) score -= 10;
    if (cachePerf.memoryUsageMB > 40) score -= 20;
    
    if (apiPerf.avgResponseTime > 1000) score -= 15;
    if (apiPerf.avgResponseTime > 2000) score -= 25;

    if (score >= 80) return 'excellent';
    if (score >= 60) return 'good';
    if (score >= 40) return 'fair';
    return 'poor';
  }

  /**
   * Generates optimization recommendations based on performance metrics
   * Provides actionable suggestions for improving performance
   * 
   * @param cachePerf - Cache performance metrics
   * @param apiPerf - API performance metrics
   * @returns Array of recommendation strings
   * @private
   */
  private generateRecommendations(cachePerf: CachePerformanceMetrics, apiPerf: ApiPerformanceMetrics): string[] {
    const recommendations: string[] = [];

    if (cachePerf.hitRate < 70) {
      recommendations.push('Consider increasing cache TTL values or improving cache key strategy');
    }

    if (cachePerf.memoryUsageMB > 35) {
      recommendations.push('Consider implementing more aggressive cache eviction or reducing cache size');
    }

    if (apiPerf.avgResponseTime > 1000) {
      recommendations.push('Review API endpoint performance and consider query optimization');
    }

    if (apiPerf.backgroundSyncStatus !== 'active') {
      recommendations.push('Check background sync process - may be failing or not running');
    }

    if (recommendations.length === 0) {
      recommendations.push('Performance metrics look good - no immediate action required');
    }

    return recommendations;
  }

  /**
   * Exports metrics in a standardized format for external monitoring systems
   * Provides compatibility with external APM tools and monitoring services
   * 
   * @returns Exported metrics with version and timestamp
   * @example
   * ```typescript
   * const exported = await performanceMonitor.exportMetrics();
   * // Returns: { timestamp: 1640995200000, version: '1.0', metrics: {...} }
   * ```
   */
  async exportMetrics(): Promise<ExportedMetrics> {
    const report = await this.getPerformanceReport();
    
    return {
      timestamp: Date.now(),
      version: '1.0',
      metrics: report
    };
  }

  /**
   * Cleans up monitoring resources
   * Stops background intervals and performs cleanup
   */
  cleanup(): void {
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
      this.monitoringInterval = null;
    }
  }
}

/**
 * Performance Optimization Utilities
 * 
 * Provides utility functions for performance optimization including
 * cache warming, memory optimization, and query optimization suggestions.
 * 
 * @class PerformanceOptimizer
 */
class PerformanceOptimizer {
  /**
   * Intelligently warms the cache based on usage patterns
   * Preloads popular items and critical data to improve response times
   * 
   * @example
   * ```typescript
   * await PerformanceOptimizer.warmCache();
   * // Preloads popular flavors, ingredients, suppliers, and search results
   * ```
   */
  static async warmCache(): Promise<void> {
    try {
      logger.info('Starting intelligent cache warming');
      
      // Preload popular items based on patterns
      const warmingTasks = [
        () => optimizedDataService.getFlavors({ page: 1, limit: 10 }),
        () => optimizedDataService.getIngredients({ limit: 50 }),
        () => optimizedDataService.getSuppliers({ limit: 50 }),
        () => optimizedDataService.search('energy', { limit: 5 }),
        () => optimizedDataService.search('caffeine', { limit: 5 })
      ];

      const results = await Promise.allSettled(
        warmingTasks.map(task => task())
      );

      const successCount = results.filter(r => r.status === 'fulfilled').length;
      logger.info(`Cache warming completed: ${successCount}/${warmingTasks.length} tasks successful`);
    } catch (error) {
      logger.error('Cache warming failed', error);
    }
  }

  /**
   * Optimizes memory usage by triggering garbage collection
   * Works in both browser and Node.js environments
   * 
   * @example
   * ```typescript
   * PerformanceOptimizer.optimizeMemoryUsage();
   * // Triggers garbage collection where available
   * ```
   */
  static optimizeMemoryUsage(): void {
    if (typeof window !== 'undefined') {
      // Browser: Suggest garbage collection
      if (window.gc) {
        window.gc();
      }
    } else {
      // Node.js: Force garbage collection if available
      if (global.gc) {
        global.gc();
      }
    }
  }

  /**
   * Generates query optimization suggestions based on performance statistics
   * Analyzes query performance and suggests optimization strategies
   * 
   * @param stats - Performance statistics to analyze
   * @returns Array of optimization suggestions
   * @example
   * ```typescript
   * const suggestions = PerformanceOptimizer.generateQueryOptimizationSuggestions(stats);
   * // Returns suggestions like "Consider implementing pagination"
   * ```
   */
  static generateQueryOptimizationSuggestions(stats: PerformanceStats): string[] {
    const suggestions: string[] = [];

    if (stats.p95 > 2000) {
      suggestions.push('Consider implementing query result pagination');
      suggestions.push('Review database indexes for slow queries');
    }

    if (stats.avg > 1000) {
      suggestions.push('Implement query result caching');
      suggestions.push('Consider data denormalization for frequently accessed data');
    }

    if (stats.count > 1000) {
      suggestions.push('Implement request rate limiting');
      suggestions.push('Consider data prefetching strategies');
    }

    return suggestions;
  }
}

// Performance Alert Interface
/**
 * Represents a performance alert generated by monitoring
 * @interface PerformanceAlert
 */
interface PerformanceAlert {
  /** Type/category of the alert */
  type: string;
  /** Severity level of the alert */
  severity: 'info' | 'warning' | 'error';
  /** Human-readable alert message */
  message: string;
  /** Current metric value that triggered the alert */
  value: number;
  /** Threshold value that was exceeded */
  threshold: number;
  /** Timestamp when alert was generated */
  timestamp: number;
}

// Performance Statistics Interface
/**
 * Statistical measures for performance metrics
 * @interface PerformanceStats
 */
interface PerformanceStats {
  /** Number of data points */
  count: number;
  /** Average value */
  avg: number;
  /** Minimum value */
  min: number;
  /** Maximum value */
  max: number;
  /** 50th percentile (median) */
  p50: number;
  /** 95th percentile */
  p95: number;
  /** 99th percentile */
  p99: number;
}

// Cache Performance Metrics Interface
/**
 * Cache-specific performance metrics
 * @interface CachePerformanceMetrics
 */
interface CachePerformanceMetrics {
  /** Cache hit rate percentage */
  hitRate: number;
  /** Current memory usage in megabytes */
  memoryUsageMB: number;
  /** Average response time in milliseconds */
  avgResponseTime: number;
  /** Total number of cache requests */
  totalRequests: number;
  /** Number of cache evictions */
  evictions: number;
}

// API Performance Metrics Interface
/**
 * API-specific performance metrics
 * @interface ApiPerformanceMetrics
 */
interface ApiPerformanceMetrics {
  /** Average API response time in milliseconds */
  avgResponseTime: number;
  /** API cache hit rate percentage */
  cacheHitRate: number;
  /** Current memory usage in megabytes */
  memoryUsage: number;
  /** Background synchronization status */
  backgroundSyncStatus: string;
}

// Performance Report Interface
/**
 * Comprehensive performance report structure
 * @interface PerformanceReport
 */
interface PerformanceReport {
  /** Report generation timestamp */
  timestamp: number;
  /** Overall performance summary */
  summary: {
    /** Overall health classification */
    overallHealth: string;
    /** Cache performance metrics */
    cache: CachePerformanceMetrics;
    /** API performance metrics */
    api: ApiPerformanceMetrics;
  };
  /** Detailed statistics for all metrics */
  detailedStats: Record<string, PerformanceStats>;
  /** Recent performance alerts */
  recentAlerts: PerformanceAlert[];
  /** Performance optimization recommendations */
  recommendations: string[];
}

// Exported Metrics Interface
/**
 * Standardized metrics export format
 * @interface ExportedMetrics
 */
interface ExportedMetrics {
  /** Export timestamp */
  timestamp: number;
  /** Metrics version */
  version: string;
  /** Performance metrics data */
  metrics: PerformanceReport;
}

/**
 * Performance Monitor Singleton Instance
 * 
 * Main entry point for performance monitoring. This singleton provides
 * real-time monitoring, alerting, and optimization recommendations.
 * 
 * @example
 * ```typescript
 * // Record custom metrics
 * performanceMonitor.recordMetric('custom.operation', 150);
 * 
 * // Get performance report
 * const report = await performanceMonitor.getPerformanceReport();
 * console.log(report.summary.overallHealth); // 'good'
 * ```
 */
export const performanceMonitor = new PerformanceMonitor();

/** Export the PerformanceOptimizer class */
export { PerformanceOptimizer };

// Auto-start monitoring in production
if (process.env.NODE_ENV === 'production') {
  performanceMonitor.recordMetric('app.start', Date.now());
}

// Cleanup on process exit
if (typeof window === 'undefined') {
  process.on('SIGTERM', () => {
    performanceMonitor.cleanup();
  });
  
  process.on('SIGINT', () => {
    performanceMonitor.cleanup();
  });
}
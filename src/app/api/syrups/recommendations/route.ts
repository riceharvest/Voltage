/**
 * Syrup Recommendations API Route
 * 
 * API endpoint for intelligent syrup recommendations based on target flavors,\n * dietary preferences, budget constraints, and compatibility analysis.\n * \n * @example\n * ```typescript\n * // Get smart recommendations for a flavor\n * GET /api/syrups/recommendations?flavor=vanilla&budget=15&quality=high\n * \n * // Get hybrid recipe recommendations\n * POST /api/syrups/recommendations/hybrid\n * {\n *   \"targetFlavor\": \"caramel\",\n *   \"qualityTarget\": \"premium\",\n *   \"budget\": 20\n * }\n * ```\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { SyrupRecommendation, PremadeSyrup } from '@/lib/types';\nimport { PremadeSyrupService } from '@/lib/premade-syrups';\nimport { HybridRecipeService } from '@/lib/hybrid-recipes';\nimport { syrupDatabase } from '@/data/syrups';\n\n/**\n * Recommendation request interface\n */\ninterface RecommendationRequest {\n  flavor: string;\n  budget?: number;\n  brand?: string;\n  quality?: 'budget' | 'standard' | 'premium';\n  availability?: string;\n  dietary?: string[];\n  useCase?: 'coffee' | 'soda' | 'dessert' | 'beverage' | 'cocktail';\n  maxResults?: number;\n}\n\n/**\n * Hybrid recommendation request interface\n */\ninterface HybridRecommendationRequest {\n  targetFlavor: string;\n  qualityTarget?: 'basic' | 'good' | 'high' | 'premium';\n  budget?: number;\n  preparationTime?: number;\n  complexity?: 'beginner' | 'intermediate' | 'advanced';\n  customAdditions?: Array<{\n    type: 'extract' | 'oil' | 'acid' | 'sweetener' | 'preservative';\n    id: string;\n    amount: number;\n    unit: 'ml' | 'g' | 'tsp' | 'drops';\n  }>;\n}\n\n/**\n * Initialize services (singleton pattern)\n */\nlet syrupService: PremadeSyrupService | null = null;\nlet hybridService: HybridRecipeService | null = null;\n\nfunction getSyrupService(): PremadeSyrupService {\n  if (!syrupService) {\n    syrupService = new PremadeSyrupService();\n    // Override with comprehensive database\n    (syrupService as any).syrups = syrupDatabase;\n  }\n  return syrupService;\n}\n\nfunction getHybridService(): HybridRecipeService {\n  if (!hybridService) {\n    const syrupSvc = getSyrupService();\n    hybridService = new HybridRecipeService(syrupSvc);\n  }\n  return hybridService;\n}\n\n/**\n * GET /api/syrups/recommendations - Get smart syrup recommendations\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const flavor = searchParams.get('flavor');\n    const budget = searchParams.get('budget');\n    const brand = searchParams.get('brand');\n    const quality = searchParams.get('quality') as any;\n    const availability = searchParams.get('availability');\n    const dietary = searchParams.get('dietary');\n    const useCase = searchParams.get('useCase') as any;\n    const maxResults = parseInt(searchParams.get('maxResults') || '5');\n    \n    if (!flavor) {\n      return NextResponse.json(\n        { success: false, error: 'flavor parameter is required' },\n        { status: 400 }\n      );\n    }\n    \n    const service = getSyrupService();\n    \n    // Build preferences object\n    const preferences: any = {};\n    if (budget) preferences.budget = parseFloat(budget);\n    if (brand) preferences.brand = brand;\n    if (availability) preferences.availability = availability;\n    \n    // Get base recommendations\n    let recommendations = service.getRecommendations(flavor, preferences);\n    \n    // Apply additional filters\n    if (dietary) {\n      const dietaryRestrictions = dietary.split(',');\n      recommendations = applyDietaryFilters(recommendations, dietaryRestrictions);\n    }\n    \n    // Enhance recommendations with use case data\n    if (useCase) {\n      recommendations = enhanceWithUseCase(recommendations, useCase);\n    }\n    \n    // Apply quality scoring\n    if (quality) {\n      recommendations = applyQualityScoring(recommendations, quality);\n    }\n    \n    // Sort and limit results\n    recommendations = recommendations\n      .sort((a, b) => b.compatibilityScore - a.compatibilityScore)\n      .slice(0, maxResults);\n    \n    // Generate additional insights\n    const insights = generateRecommendationInsights(recommendations, flavor, preferences);\n    \n    return NextResponse.json({\n      success: true,\n      data: {\n        targetFlavor: flavor,\n        recommendations,\n        insights,\n        filters: {\n          budget: preferences.budget,\n          brand: preferences.brand,\n          quality,\n          availability,\n          dietary: dietary ? dietary.split(',') : [],\n          useCase\n        },\n        metadata: {\n          totalFound: recommendations.length,\n          searchParams: Object.fromEntries(searchParams.entries())\n        }\n      }\n    });\n    \n  } catch (error) {\n    console.error('Error getting recommendations:', error);\n    return NextResponse.json(\n      { \n        success: false, \n        error: 'Failed to get recommendations',\n        message: error instanceof Error ? error.message : 'Unknown error'\n      },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * POST /api/syrups/recommendations/hybrid - Get hybrid recipe recommendations\n */\nexport async function POST_HYBRID(request: NextRequest) {\n  try {\n    const body = await request.json();\n    \n    const {\n      targetFlavor,\n      qualityTarget = 'good',\n      budget = 20,\n      preparationTime = 15,\n      complexity = 'intermediate',\n      customAdditions = []\n    } = body as HybridRecommendationRequest;\n    \n    if (!targetFlavor) {\n      return NextResponse.json(\n        { success: false, error: 'targetFlavor is required' },\n        { status: 400 }\n      );\n    }\n    \n    const hybridService = getHybridService();\n    \n    // Create hybrid recipe options\n    const options = {\n      targetFlavor,\n      qualityTarget,\n      budget,\n      preparationTime,\n      complexity,\n      customAdditions\n    };\n    \n    // Generate hybrid recipe\n    const hybridRecipe = await hybridService.createHybridRecipe(options);\n    \n    // Get compatibility analysis\n    const compatibility = hybridService.analyzeCompatibility(\n      hybridRecipe.baseSyrup!,\n      hybridRecipe.recipe.customAdditions || []\n    );\n    \n    // Generate alternatives\n    const alternatives = hybridRecipe.alternatives || [];\n    \n    return NextResponse.json({\n      success: true,\n      data: {\n        targetFlavor,\n        hybridRecipe,\n        compatibility,\n        alternatives: alternatives.slice(0, 3), // Top 3 alternatives\n        metadata: {\n          generatedAt: new Date().toISOString(),\n          options\n        }\n      }\n    });\n    \n  } catch (error) {\n    console.error('Error generating hybrid recommendations:', error);\n    return NextResponse.json(\n      { \n        success: false, \n        error: 'Failed to generate hybrid recommendations',\n        message: error instanceof Error ? error.message : 'Unknown error'\n      },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * GET /api/syrups/recommendations/popular - Get popular/trending syrups\n */\nexport async function GET_POPULAR(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const category = searchParams.get('category');\n    const region = searchParams.get('region') || 'EU';\n    const limit = parseInt(searchParams.get('limit') || '10');\n    \n    const service = getSyrupService();\n    const allSyrups = service.getAllSyrups();\n    \n    // Filter by category if specified\n    let filteredSyrups = allSyrups;\n    if (category) {\n      filteredSyrups = allSyrups.filter(syrup => syrup.category === category);\n    }\n    \n    // Sort by popularity (combination of rating and review count)\n    const popularSyrups = filteredSyrups\n      .map(syrup => ({\n        ...syrup,\n        popularityScore: calculatePopularityScore(syrup)\n      }))\n      .sort((a, b) => b.popularityScore - a.popularityScore)\n      .slice(0, limit)\n      .map(({ popularityScore, ...syrup }) => syrup); // Remove temporary score\n    \n    // Get regional pricing for the popular syrups\n    const syrupsWithPricing = popularSyrups.map(syrup => {\n      const regionalPrice = syrup.regionalPricing[region] || Object.values(syrup.regionalPricing)[0];\n      return {\n        ...syrup,\n        regionalPricing: {\n          [region]: regionalPrice\n        }\n      };\n    });\n    \n    return NextResponse.json({\n      success: true,\n      data: {\n        region,\n        category,\n        syrups: syrupsWithPricing,\n        metadata: {\n          totalFound: syrupsWithPricing.length,\n          region,\n          category,\n          generatedAt: new Date().toISOString()\n        }\n      }\n    });\n    \n  } catch (error) {\n    console.error('Error getting popular syrups:', error);\n    return NextResponse.json(\n      { \n        success: false, \n        error: 'Failed to get popular syrups',\n        message: error instanceof Error ? error.message : 'Unknown error'\n      },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * Helper functions\n */\n\n/**\n * Apply dietary filters to recommendations\n */\nfunction applyDietaryFilters(\n  recommendations: SyrupRecommendation[],\n  dietaryRestrictions: string[]\n): SyrupRecommendation[] {\n  return recommendations.filter(rec => {\n    const syrup = rec.syrup;\n    \n    // Check for sugar-free\n    if (dietaryRestrictions.includes('sugar-free')) {\n      const isSugarFree = syrup.name.toLowerCase().includes('sugar-free') ||\n                         syrup.brand.toLowerCase().includes('skinny') ||\n                         syrup.brand.toLowerCase().includes('jordan');\n      if (!isSugarFree) return false;\n    }\n    \n    // Check for organic (simplified check)\n    if (dietaryRestrictions.includes('organic')) {\n      const isOrganic = syrup.description.toLowerCase().includes('organic') ||\n                       syrup.name.toLowerCase().includes('organic');\n      if (!isOrganic) return false;\n    }\n    \n    // Check for vegan\n    if (dietaryRestrictions.includes('vegan')) {\n      const isVegan = !syrup.name.toLowerCase().includes('honey') &&\n                     !syrup.description.toLowerCase().includes('honey') &&\n                     !syrup.description.toLowerCase().includes('dairy');\n      if (!isVegan) return false;\n    }\n    \n    return true;\n  });\n}\n\n/**\n * Enhance recommendations with use case data\n */\nfunction enhanceWithUseCase(\n  recommendations: SyrupRecommendation[],\n  useCase: string\n): SyrupRecommendation[] {\n  return recommendations.map(rec => {\n    const syrup = rec.syrup;\n    \n    // Add use case specific scoring\n    let useCaseScore = 0;\n    const useCaseCompatibility = {\n      coffee: ['vanilla', 'caramel', 'hazelnut', 'mocha', 'coffee'],\n      soda: ['cola', 'lemon', 'lime', 'orange', 'fruit'],\n      dessert: ['vanilla', 'caramel', 'chocolate', 'hazelnut'],\n      beverage: ['fruit', 'citrus', 'berry', 'tropical'],\n      cocktail: ['cranberry', 'lime', 'orange', 'mint']\n    };\n    \n    const compatibleFlavors = useCaseCompatibility[useCase as keyof typeof useCaseCompatibility] || [];\n    if (compatibleFlavors.some(flavor => \n      syrup.compatibleFlavors.includes(flavor) ||\n      syrup.name.toLowerCase().includes(flavor) ||\n      syrup.tasteProfile.notes.some(note => note.toLowerCase().includes(flavor))\n    )) {\n      useCaseScore = 15;\n    }\n    \n    return {\n      ...rec,\n      compatibilityScore: Math.min(100, rec.compatibilityScore + useCaseScore),\n      reasons: [\n        ...rec.reasons,\n        `Excellent for ${useCase} applications`\n      ]\n    };\n  });\n}\n\n/**\n * Apply quality-based scoring\n */\nfunction applyQualityScoring(\n  recommendations: SyrupRecommendation[],\n  quality: string\n): SyrupRecommendation[] {\n  const qualityWeights = {\n    budget: { rating: 0.3, price: 0.7 },\n    standard: { rating: 0.6, price: 0.4 },\n    premium: { rating: 0.8, price: 0.2 }\n  };\n  \n  const weights = qualityWeights[quality as keyof typeof qualityWeights] || qualityWeights.standard;\n  \n  return recommendations.map(rec => {\n    const syrup = rec.syrup;\n    const minPrice = Math.min(...Object.values(syrup.regionalPricing).map(p => p.price));\n    \n    // Calculate quality-adjusted score\n    const ratingScore = (syrup.rating / 5) * 100;\n    const priceScore = Math.max(0, 100 - (minPrice / 25) * 100); // Normalize price\n    const qualityScore = (ratingScore * weights.rating) + (priceScore * weights.price);\n    \n    return {\n      ...rec,\n      compatibilityScore: Math.round(qualityScore),\n      reasons: [\n        ...rec.reasons,\n        quality === 'premium' ? 'Premium quality selection' :\n        quality === 'budget' ? 'Budget-friendly option' :\n        'Balanced quality and value'\n      ]\n    };\n  });\n}\n\n/**\n * Generate recommendation insights\n */\nfunction generateRecommendationInsights(\n  recommendations: SyrupRecommendation[],\n  flavor: string,\n  preferences: any\n) {\n  if (recommendations.length === 0) {\n    return {\n      message: 'No recommendations found for the specified criteria',\n      suggestions: [\n        'Try broadening your search criteria',\n        'Consider alternative flavors',\n        'Check budget constraints'\n      ]\n    };\n  }\n  \n  const topRecommendation = recommendations[0];\n  const averageScore = recommendations.reduce((sum, rec) => sum + rec.compatibilityScore, 0) / recommendations.length;\n  \n  return {\n    summary: {\n      totalMatches: recommendations.length,\n      averageCompatibility: Math.round(averageScore),\n      topMatch: {\n        name: topRecommendation.syrup.name,\n        brand: topRecommendation.syrup.brand,\n        score: topRecommendation.compatibilityScore\n      }\n    },\n    insights: [\n      `Found ${recommendations.length} syrups matching ${flavor} profile`,\n      `Top recommendation scores ${topRecommendation.compatibilityScore}% compatibility`,\n      preferences.budget ? `Within budget of â‚¬${preferences.budget}` : null,\n      preferences.brand ? `Focused on ${preferences.brand} brand` : null\n    ].filter(Boolean),\n    trends: {\n      priceRange: {\n        min: Math.min(...recommendations.map(rec => \n          Math.min(...Object.values(rec.syrup.regionalPricing).map(p => p.price))\n        )),\n        max: Math.max(...recommendations.map(rec => \n          Math.max(...Object.values(rec.syrup.regionalPricing).map(p => p.price))\n        ))\n      },\n      topBrands: getTopBrands(recommendations),\n      availabilityStatus: getAvailabilityBreakdown(recommendations)\n    }\n  };\n}\n\n/**\n * Calculate popularity score for syrups\n */\nfunction calculatePopularityScore(syrup: PremadeSyrup): number {\n  // Combine rating and review count for popularity\n  const ratingWeight = 0.6;\n  const reviewWeight = 0.4;\n  \n  const ratingScore = (syrup.rating / 5) * 100;\n  const reviewScore = Math.min(100, (syrup.reviewCount / 5000) * 100); // Normalize reviews\n  \n  return (ratingScore * ratingWeight) + (reviewScore * reviewWeight);\n}\n\n/**\n * Get top brands from recommendations\n */\nfunction getTopBrands(recommendations: SyrupRecommendation[]): string[] {\n  const brandCounts = recommendations.reduce((acc, rec) => {\n    acc[rec.syrup.brand] = (acc[rec.syrup.brand] || 0) + 1;\n    return acc;\n  }, {} as Record<string, number>);\n  \n  return Object.entries(brandCounts)\n    .sort(([,a], [,b]) => b - a)\n    .slice(0, 3)\n    .map(([brand]) => brand);\n}\n\n/**\n * Get availability breakdown\n */\nfunction getAvailabilityBreakdown(recommendations: SyrupRecommendation[]): Record<string, number> {\n  return recommendations.reduce((acc, rec) => {\n    const availability = rec.syrup.availability;\n    acc[availability] = (acc[availability] || 0) + 1;\n    return acc;\n  }, {} as Record<string, number>);\n}"
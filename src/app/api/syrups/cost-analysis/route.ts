/**
 * Syrup Cost Analysis API Route
 * 
 * API endpoint for comprehensive cost analysis comparing DIY vs premade\n * approaches, regional pricing, and bulk purchasing recommendations.\n * \n * @example\n * ```typescript\n * // Analyze cost comparison for a flavor\n * POST /api/syrups/cost-analysis\n * {\n *   \"targetFlavor\": \"vanilla\",\n *   \"diyRecipe\": { /* DIY recipe data */ },\n *   \"targetServingSize\": 250,\n *   \"batchSize\": 20,\n *   \"region\": \"EU\",\n *   \"qualityPreference\": \"standard\"\n * }\n * ```\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { CostAnalysisInput, ComprehensiveCostAnalysis } from '@/lib/premade-cost-analysis';\nimport { PremadeCostAnalysis } from '@/lib/premade-cost-analysis';\nimport { PremadeSyrupService } from '@/lib/premade-syrups';\nimport { syrupDatabase } from '@/data/syrups';\n\n/**\n * Initialize services (singleton pattern)\n */\nlet costAnalyzer: PremadeCostAnalysis | null = null;\nlet syrupService: PremadeSyrupService | null = null;\n\nfunction getCostAnalyzer(): PremadeCostAnalysis {\n  if (!costAnalyzer) {\n    const syrupSvc = getSyrupService();\n    costAnalyzer = new PremadeCostAnalysis(syrupSvc);\n  }\n  return costAnalyzer;\n}\n\nfunction getSyrupService(): PremadeSyrupService {\n  if (!syrupService) {\n    syrupService = new PremadeSyrupService();\n    // Override with comprehensive database\n    (syrupService as any).syrups = syrupDatabase;\n  }\n  return syrupService;\n}\n\n/**\n * POST /api/syrups/cost-analysis - Perform comprehensive cost analysis\n */\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    \n    // Validate required parameters\n    const requiredFields = ['targetFlavor', 'diyRecipe', 'targetServingSize', 'batchSize'];\n    const missingFields = requiredFields.filter(field => !(field in body));\n    \n    if (missingFields.length > 0) {\n      return NextResponse.json(\n        { \n          success: false, \n          error: `Missing required fields: ${missingFields.join(', ')}` \n        },\n        { status: 400 }\n      );\n    }\n    \n    const {\n      targetFlavor,\n      diyRecipe,\n      targetServingSize,\n      batchSize,\n      region = 'EU',\n      currency = 'EUR',\n      qualityPreference = 'standard',\n      timeframe = 'monthly'\n    } = body as CostAnalysisInput;\n    \n    // Validate DIY recipe structure\n    if (!diyRecipe.ingredients || !Array.isArray(diyRecipe.ingredients) || diyRecipe.ingredients.length === 0) {\n      return NextResponse.json(\n        { success: false, error: 'diyRecipe.ingredients must be a non-empty array' },\n        { status: 400 }\n      );\n    }\n    \n    // Validate numeric parameters\n    if (targetServingSize <= 0 || batchSize <= 0) {\n      return NextResponse.json(\n        { success: false, error: 'targetServingSize and batchSize must be positive numbers' },\n        { status: 400 }\n      );\n    }\n    \n    const analyzer = getCostAnalyzer();\n    \n    // Perform cost analysis\n    const analysis = await analyzer.analyzeCostComparison({\n      targetFlavor,\n      diyRecipe,\n      targetServingSize,\n      batchSize,\n      region,\n      currency,\n      qualityPreference,\n      timeframe\n    });\n    \n    // Add additional insights\n    const insights = {\n      savingsBreakdown: calculateSavingsBreakdown(analysis),\n      optimizationOpportunities: identifyOptimizationOpportunities(analysis),\n      marketFactors: analyzeMarketFactors(analysis),\n      recommendations: generateActionableRecommendations(analysis)\n    };\n    \n    return NextResponse.json({\n      success: true,\n      data: {\n        analysis,\n        insights,\n        metadata: {\n          analyzedAt: new Date().toISOString(),\n          region,\n          currency,\n          qualityPreference,\n          batchSize,\n          targetServingSize\n        }\n      }\n    });\n    \n  } catch (error) {\n    console.error('Error performing cost analysis:', error);\n    return NextResponse.json(\n      { \n        success: false, \n        error: 'Failed to perform cost analysis',\n        message: error instanceof Error ? error.message : 'Unknown error'\n      },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * GET /api/syrups/cost-analysis/compare - Quick cost comparison\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const flavor = searchParams.get('flavor');\n    const batchSize = parseInt(searchParams.get('batchSize') || '20');\n    const region = searchParams.get('region') || 'EU';\n    const approach = searchParams.get('approach') as 'diy' | 'premade' | 'hybrid';\n    \n    if (!flavor) {\n      return NextResponse.json(\n        { success: false, error: 'flavor parameter is required' },\n        { status: 400 }\n      );\n    }\n    \n    const analyzer = getCostAnalyzer();\n    \n    // Create simplified DIY recipe for comparison\n    const diyRecipe = {\n      ingredients: [\n        {\n          id: 'flavor-extract',\n          name: 'Flavor Extract',\n          amount: 5,\n          unit: 'ml',\n          cost: 8.00,\n          supplier: 'local',\n          shelfLife: 365\n        },\n        {\n          id: 'sweetener',\n          name: 'Natural Sweetener',\n          amount: 20,\n          unit: 'ml',\n          cost: 3.50,\n          supplier: 'local',\n          shelfLife: 180\n        }\n      ],\n      laborTime: 25,\n      equipmentNeeded: ['digital-scale', 'mixing-bowls', 'whisk'],\n      difficulty: 'intermediate' as const\n    };\n    \n    const analysis = await analyzer.analyzeCostComparison({\n      targetFlavor: flavor,\n      diyRecipe,\n      targetServingSize: 250,\n      batchSize,\n      region,\n      currency: 'EUR',\n      qualityPreference: 'standard'\n    });\n    \n    // Return simplified comparison based on approach\n    let comparisonData;\n    switch (approach) {\n      case 'diy':\n        comparisonData = analysis.diy;\n        break;\n      case 'premade':\n        comparisonData = analysis.premade;\n        break;\n      case 'hybrid':\n        comparisonData = analysis.hybrid;\n        break;\n      default:\n        comparisonData = {\n          diy: analysis.diy,\n          premade: analysis.premade,\n          hybrid: analysis.hybrid,\n          recommendation: analysis.recommendation\n        };\n    }\n    \n    return NextResponse.json({\n      success: true,\n      data: {\n        flavor,\n        approach: approach || 'all',\n        region,\n        batchSize,\n        comparison: comparisonData,\n        recommendation: analysis.recommendation\n      }\n    });\n    \n  } catch (error) {\n    console.error('Error performing cost comparison:', error);\n    return NextResponse.json(\n      { \n        success: false, \n        error: 'Failed to perform cost comparison',\n        message: error instanceof Error ? error.message : 'Unknown error'\n      },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * Helper functions for additional insights\n */\n\n/**\n * Calculate detailed savings breakdown\n */\nfunction calculateSavingsBreakdown(analysis: ComprehensiveCostAnalysis) {\n  const { diy, premade, hybrid } = analysis;\n  \n  return {\n    vsPremade: {\n      absolute: diy.totalCost - premade.totalCost,\n      percentage: ((diy.totalCost - premade.totalCost) / diy.totalCost) * 100,\n      perServing: diy.costPerServing - premade.costPerServing\n    },\n    vsHybrid: {\n      absolute: diy.totalCost - hybrid.totalCost,\n      percentage: ((diy.totalCost - hybrid.totalCost) / diy.totalCost) * 100,\n      perServing: diy.costPerServing - hybrid.costPerServing\n    },\n    premadeVsHybrid: {\n      absolute: premade.totalCost - hybrid.totalCost,\n      percentage: ((premade.totalCost - hybrid.totalCost) / premade.totalCost) * 100,\n      perServing: premade.costPerServing - hybrid.costPerServing\n    }\n  };\n}\n\n/**\n * Identify optimization opportunities\n */\nfunction identifyOptimizationOpportunities(analysis: ComprehensiveCostAnalysis) {\n  const opportunities = [];\n  const { optimizationOpportunities } = analysis;\n  \n  // Cost reduction opportunities\n  if (optimizationOpportunities.costReduction.length > 0) {\n    opportunities.push({\n      category: 'Cost Reduction',\n      potentialSavings: optimizationOpportunities.costReduction.reduce((sum, opp) => sum + opp.potentialSavings, 0),\n      items: optimizationOpportunities.costReduction\n    });\n  }\n  \n  // Quality improvement opportunities\n  if (optimizationOpportunities.qualityImprovement.length > 0) {\n    opportunities.push({\n      category: 'Quality Enhancement',\n      potentialGain: optimizationOpportunities.qualityImprovement.reduce((sum, opp) => sum + opp.qualityGain, 0),\n      items: optimizationOpportunities.qualityImprovement\n    });\n  }\n  \n  return opportunities;\n}\n\n/**\n * Analyze market factors affecting pricing\n */\nfunction analyzeMarketFactors(analysis: ComprehensiveCostAnalysis) {\n  const { marketTrends, regionalPricing } = analysis;\n  \n  return {\n    priceVolatility: marketTrends.priceVolatility,\n    seasonalImpact: marketTrends.seasonalFactors.reduce((sum, factor) => sum + Math.abs(factor.impact), 0),\n    futureOutlook: marketTrends.futureOutlook,\n    regionalFactors: {\n      taxRate: regionalPricing.taxRate,\n      shippingCost: regionalPricing.shippingCost,\n      availabilityFactor: regionalPricing.availabilityFactor\n    },\n    recommendations: [\n      marketTrends.priceVolatility === 'high' ? 'Consider bulk purchasing to lock in prices' : null,\n      regionalPricing.availabilityFactor < 0.9 ? 'Monitor availability and consider alternatives' : null,\n      regionalPricing.shippingCost > 5 ? 'Look for local suppliers to reduce shipping costs' : null\n    ].filter(Boolean)\n  };\n}\n\n/**\n * Generate actionable recommendations\n */\nfunction generateActionableRecommendations(analysis: ComprehensiveCostAnalysis) {\n  const recommendations = [];\n  const { recommendation, qualityAssessment, costAnalysis } = analysis;\n  \n  // Primary recommendation\n  recommendations.push({\n    type: 'primary',\n    approach: recommendation.preferred,\n    confidence: recommendation.confidence,\n    reasoning: recommendation.reasoning\n  });\n  \n  // Quality-based recommendations\n  Object.entries(qualityAssessment).forEach(([approach, assessment]) => {\n    if (assessment.recommendation === 'highly-recommended') {\n      recommendations.push({\n        type: 'quality',\n        approach,\n        reason: 'High quality score with excellent user ratings',\n        score: assessment.overallRating\n      });\n    }\n  });\n  \n  // Cost-based recommendations\n  if (analysis.diy.totalCost > analysis.premade.totalCost * 1.5) {\n    recommendations.push({\n      type: 'cost',\n      approach: 'premade',\n      reason: 'Significant cost savings over DIY approach',\n      savings: analysis.diy.totalCost - analysis.premade.totalCost\n    });\n  }\n  \n  // Alternative scenarios\n  recommendation.alternativeScenarios.forEach(scenario => {\n    if (scenario.quality > 80) {\n      recommendations.push({\n        type: 'alternative',\n        approach: scenario.approach,\n        reason: scenario.whenToUse,\n        quality: scenario.quality\n      });\n    }\n  });\n  \n  return recommendations;\n}"